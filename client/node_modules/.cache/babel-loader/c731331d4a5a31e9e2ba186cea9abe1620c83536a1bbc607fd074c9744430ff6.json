{"ast":null,"code":"/**\n * Match classification utilities\n */\n\n/**\n * Determine match type based on PUBG API response data\n * @param {Object} matchData - Match data from PUBG API\n * @returns {String} Match type (RANKED, CUSTOM, or PUBLIC)\n */\nexport const getMatchType = matchData => {\n  if (!matchData || !matchData.data || !matchData.data.attributes) {\n    return 'PUBLIC';\n  }\n  const attributes = matchData.data.attributes;\n\n  // Use the matchType attribute as the primary classification method\n  if (attributes.matchType === 'competitive') {\n    return 'RANKED';\n  } else if (attributes.matchType === 'custom' || attributes.isCustomMatch === true) {\n    return 'CUSTOM';\n  } else if (attributes.matchType === 'official') {\n    return 'PUBLIC';\n  }\n\n  // Return meta info if available (this is from our server)\n  if (matchData.meta && matchData.meta.matchType) {\n    return matchData.meta.matchType;\n  }\n\n  // For any other case, default to PUBLIC\n  return 'PUBLIC';\n};\n\n/**\n * Get a human-readable description of match type\n * @param {String} matchType - Match type (RANKED, CUSTOM, or PUBLIC)\n * @returns {String} Human-readable description\n */\nexport const getMatchTypeDescription = matchType => {\n  switch (matchType) {\n    case 'RANKED':\n      return 'Ranked Match';\n    case 'CUSTOM':\n      return 'Custom Match';\n    case 'PUBLIC':\n      return 'Public Match';\n    default:\n      return 'Unknown Type';\n  }\n};\n\n/**\n * Get CSS class for match type\n * @param {String} matchType - Match type (RANKED, CUSTOM, or PUBLIC)\n * @returns {String} CSS class\n */\nexport const getMatchTypeClass = matchType => {\n  switch (matchType) {\n    case 'RANKED':\n      return 'ranked-match';\n    case 'CUSTOM':\n      return 'custom-match';\n    case 'PUBLIC':\n      return 'public-match';\n    default:\n      return '';\n  }\n};\n\n/**\n * Format match timestamps\n * @param {String} dateString - Date string from API\n * @returns {String} Formatted date string\n */\nexport const formatMatchDate = dateString => {\n  const options = {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit'\n  };\n  return new Date(dateString).toLocaleDateString(undefined, options);\n};\n\n/**\n * Get human-readable display of match duration\n * @param {Number} seconds - Duration in seconds\n * @returns {String} Formatted duration (MM:SS)\n */\nexport const formatMatchDuration = seconds => {\n  if (!seconds) return 'Unknown';\n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = seconds % 60;\n  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\n};","map":{"version":3,"names":["getMatchType","matchData","data","attributes","matchType","isCustomMatch","meta","getMatchTypeDescription","getMatchTypeClass","formatMatchDate","dateString","options","year","month","day","hour","minute","Date","toLocaleDateString","undefined","formatMatchDuration","seconds","minutes","Math","floor","remainingSeconds","toString","padStart"],"sources":["C:/Users/emil/OneDrive/Documents/development/apiDevelopment/pubg-tournament-tracker/client/src/utils/matchUtils.js"],"sourcesContent":["/**\n * Match classification utilities\n */\n\n/**\n * Determine match type based on PUBG API response data\n * @param {Object} matchData - Match data from PUBG API\n * @returns {String} Match type (RANKED, CUSTOM, or PUBLIC)\n */\nexport const getMatchType = (matchData) => {\n  if (!matchData || !matchData.data || !matchData.data.attributes) {\n    return 'PUBLIC';\n  }\n  \n  const attributes = matchData.data.attributes;\n  \n  // Use the matchType attribute as the primary classification method\n  if (attributes.matchType === 'competitive') {\n    return 'RANKED';\n  } else if (attributes.matchType === 'custom' || attributes.isCustomMatch === true) {\n    return 'CUSTOM';\n  } else if (attributes.matchType === 'official') {\n    return 'PUBLIC';\n  }\n  \n  // Return meta info if available (this is from our server)\n  if (matchData.meta && matchData.meta.matchType) {\n    return matchData.meta.matchType;\n  }\n  \n  // For any other case, default to PUBLIC\n  return 'PUBLIC';\n};\n\n/**\n * Get a human-readable description of match type\n * @param {String} matchType - Match type (RANKED, CUSTOM, or PUBLIC)\n * @returns {String} Human-readable description\n */\nexport const getMatchTypeDescription = (matchType) => {\n  switch (matchType) {\n    case 'RANKED':\n      return 'Ranked Match';\n    case 'CUSTOM':\n      return 'Custom Match';\n    case 'PUBLIC':\n      return 'Public Match';\n    default:\n      return 'Unknown Type';\n  }\n};\n\n/**\n * Get CSS class for match type\n * @param {String} matchType - Match type (RANKED, CUSTOM, or PUBLIC)\n * @returns {String} CSS class\n */\nexport const getMatchTypeClass = (matchType) => {\n  switch (matchType) {\n    case 'RANKED':\n      return 'ranked-match';\n    case 'CUSTOM':\n      return 'custom-match';\n    case 'PUBLIC':\n      return 'public-match';\n    default:\n      return '';\n  }\n};\n\n/**\n * Format match timestamps\n * @param {String} dateString - Date string from API\n * @returns {String} Formatted date string\n */\nexport const formatMatchDate = (dateString) => {\n  const options = { \n    year: 'numeric', \n    month: 'short', \n    day: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  };\n  return new Date(dateString).toLocaleDateString(undefined, options);\n};\n\n/**\n * Get human-readable display of match duration\n * @param {Number} seconds - Duration in seconds\n * @returns {String} Formatted duration (MM:SS)\n */\nexport const formatMatchDuration = (seconds) => {\n  if (!seconds) return 'Unknown';\n  \n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = seconds % 60;\n  \n  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\n};\n"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,YAAY,GAAIC,SAAS,IAAK;EACzC,IAAI,CAACA,SAAS,IAAI,CAACA,SAAS,CAACC,IAAI,IAAI,CAACD,SAAS,CAACC,IAAI,CAACC,UAAU,EAAE;IAC/D,OAAO,QAAQ;EACjB;EAEA,MAAMA,UAAU,GAAGF,SAAS,CAACC,IAAI,CAACC,UAAU;;EAE5C;EACA,IAAIA,UAAU,CAACC,SAAS,KAAK,aAAa,EAAE;IAC1C,OAAO,QAAQ;EACjB,CAAC,MAAM,IAAID,UAAU,CAACC,SAAS,KAAK,QAAQ,IAAID,UAAU,CAACE,aAAa,KAAK,IAAI,EAAE;IACjF,OAAO,QAAQ;EACjB,CAAC,MAAM,IAAIF,UAAU,CAACC,SAAS,KAAK,UAAU,EAAE;IAC9C,OAAO,QAAQ;EACjB;;EAEA;EACA,IAAIH,SAAS,CAACK,IAAI,IAAIL,SAAS,CAACK,IAAI,CAACF,SAAS,EAAE;IAC9C,OAAOH,SAAS,CAACK,IAAI,CAACF,SAAS;EACjC;;EAEA;EACA,OAAO,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMG,uBAAuB,GAAIH,SAAS,IAAK;EACpD,QAAQA,SAAS;IACf,KAAK,QAAQ;MACX,OAAO,cAAc;IACvB,KAAK,QAAQ;MACX,OAAO,cAAc;IACvB,KAAK,QAAQ;MACX,OAAO,cAAc;IACvB;MACE,OAAO,cAAc;EACzB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMI,iBAAiB,GAAIJ,SAAS,IAAK;EAC9C,QAAQA,SAAS;IACf,KAAK,QAAQ;MACX,OAAO,cAAc;IACvB,KAAK,QAAQ;MACX,OAAO,cAAc;IACvB,KAAK,QAAQ;MACX,OAAO,cAAc;IACvB;MACE,OAAO,EAAE;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMK,eAAe,GAAIC,UAAU,IAAK;EAC7C,MAAMC,OAAO,GAAG;IACdC,IAAI,EAAE,SAAS;IACfC,KAAK,EAAE,OAAO;IACdC,GAAG,EAAE,SAAS;IACdC,IAAI,EAAE,SAAS;IACfC,MAAM,EAAE;EACV,CAAC;EACD,OAAO,IAAIC,IAAI,CAACP,UAAU,CAAC,CAACQ,kBAAkB,CAACC,SAAS,EAAER,OAAO,CAAC;AACpE,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMS,mBAAmB,GAAIC,OAAO,IAAK;EAC9C,IAAI,CAACA,OAAO,EAAE,OAAO,SAAS;EAE9B,MAAMC,OAAO,GAAGC,IAAI,CAACC,KAAK,CAACH,OAAO,GAAG,EAAE,CAAC;EACxC,MAAMI,gBAAgB,GAAGJ,OAAO,GAAG,EAAE;EAErC,OAAO,GAAGC,OAAO,IAAIG,gBAAgB,CAACC,QAAQ,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE;AACrE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}