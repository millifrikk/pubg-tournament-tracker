{"ast":null,"code":"import axios from'axios';import authService from'./authService';import cacheService from'./cacheService';// Create a service for handling match-related API calls with enhanced error handling\nconst matchesServiceEnhanced={/**\n   * Get match details by ID with caching support and better error handling\n   * @param {string} matchId - PUBG match ID\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API even if cached\n   * @returns {Promise<Object>} Match data\n   */async getMatchDetails(matchId){let platform=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'steam';let bypassCache=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;try{// First, check if we have this match cached (unless bypass requested)\nif(!bypassCache){const cachedMatch=cacheService.getMatch(matchId,platform);if(cachedMatch){console.log(`Using cached data for match: ${matchId}`);return cachedMatch;}}// Get auth token if available\nconst token=authService.getToken();// Request headers\nconst headers={};if(token){headers.Authorization=`Bearer ${token}`;}// Make API request with retry logic\nconsole.log(`Fetching match data from API: ${matchId}`);let retries=2;let lastError=null;while(retries>=0){try{const response=await axios.get(`/api/matches/${matchId}?platform=${platform}`,{headers,timeout:15000// 15 second timeout\n});// If response is empty or missing key attributes, throw an error\nif(!response.data||!response.data.data){throw new Error('Invalid response format from API');}// Cache the successful response\ncacheService.storeMatch(matchId,platform,response.data);return response.data;}catch(error){lastError=error;// If it's a 404, don't retry\nif(error.response&&error.response.status===404){throw new Error('Match not found');}// Don't retry if we've exhausted retries\nif(retries<=0){break;}// Wait before retry (1s, then 2s)\nconst delay=(2-retries)*1000+1000;console.log(`Retrying after ${delay}ms...`);await new Promise(resolve=>setTimeout(resolve,delay));retries--;}}// If we reach here, all retries failed\n// Handle specific error cases\nif(lastError.response){// Handle rate limit specifically\nif(lastError.response.status===429){console.warn('Rate limit reached for PUBG API, checking cache for fallback');// Check if we have any cached data as fallback\nconst cachedMatch=cacheService.getMatch(matchId,platform);if(cachedMatch){console.log('Using cached data due to rate limiting');return cachedMatch;}throw new Error('API rate limit exceeded and no cached data available. Please try again later.');}else if(lastError.response.status===401){throw new Error('Authentication required');}else{var _lastError$response$d;throw new Error(`API error: ${((_lastError$response$d=lastError.response.data)===null||_lastError$response$d===void 0?void 0:_lastError$response$d.error)||'Unknown error'}`);}}else if(lastError.code==='ECONNABORTED'){console.warn('Request timeout, checking cache for fallback');// Check cache as fallback\nconst cachedMatch=cacheService.getMatch(matchId,platform);if(cachedMatch){console.log('Using cached data due to timeout');return cachedMatch;}throw new Error('Request timed out. The server might be overloaded.');}else if(lastError.code==='ECONNRESET'){console.warn('Connection reset by server, checking cache for fallback');// Check cache as fallback\nconst cachedMatch=cacheService.getMatch(matchId,platform);if(cachedMatch){console.log('Using cached data due to connection reset');return cachedMatch;}throw new Error('Connection reset by server. Please try again later.');}else if(lastError.request){// No response received, check cache as fallback\nconst cachedMatch=cacheService.getMatch(matchId,platform);if(cachedMatch){console.log('Using cached data due to connection issue');return cachedMatch;}throw new Error('No response from server. Please check your connection.');}else{// Something else went wrong\nthrow lastError;}}catch(error){console.error(`Error getting match details: ${matchId}`,error);throw error;}},/**\n   * Get telemetry data for a match with caching\n   * @param {string} matchId - PUBG match ID\n   * @param {string} telemetryUrl - URL to telemetry data (if known)\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API\n   * @returns {Promise<Object>} Telemetry data\n   */async getTelemetry(matchId){let telemetryUrl=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;let platform=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'steam';let bypassCache=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;const cacheKey=`telemetry_${matchId}`;try{// Check cache first\nif(!bypassCache){// We use the regular localStorage for telemetry due to its large size\nconst cachedTelemetry=localStorage.getItem(cacheKey);if(cachedTelemetry){try{const parsed=JSON.parse(cachedTelemetry);console.log(`Using cached telemetry data for match: ${matchId}`);return parsed;}catch(e){// Invalid cache, remove it\nlocalStorage.removeItem(cacheKey);}}}// Get auth token if available\nconst token=authService.getToken();// Request headers\nconst headers={};if(token){headers.Authorization=`Bearer ${token}`;}// We need to get the telemetry URL first if not provided\nif(!telemetryUrl){console.log(`Fetching match data to get telemetry URL: ${matchId}`);// Try to get from cache first\nlet matchData=null;try{matchData=await this.getMatchDetails(matchId,platform,bypassCache);// Extract telemetry URL from match data\nif(matchData.data&&matchData.included){const assets=matchData.included.filter(item=>item.type==='asset');if(assets.length>0){var _assets$,_assets$$attributes;telemetryUrl=(_assets$=assets[0])===null||_assets$===void 0?void 0:(_assets$$attributes=_assets$.attributes)===null||_assets$$attributes===void 0?void 0:_assets$$attributes.URL;}}}catch(error){console.error('Error getting match data for telemetry:',error);}if(!telemetryUrl){throw new Error('Could not find telemetry URL for this match');}}// Make API request to get telemetry data\nconsole.log(`Fetching telemetry data for match: ${matchId}`);// Use our server endpoint instead of direct telemetry URL\n// This helps avoid CORS issues and provides better error handling\nconst response=await axios.get(`/api/telemetry/${matchId}?platform=${platform}`,{headers,timeout:45000// Extended timeout for large telemetry files\n});// Cache the telemetry data\ntry{localStorage.setItem(cacheKey,JSON.stringify(response.data));console.log(`Cached telemetry data for match: ${matchId}`);}catch(e){// Local storage might be full - telemetry can be very large\nconsole.warn('Could not cache telemetry data - likely too large for localStorage');// Try to clear some space\ncacheService.clearOldCache();}return response.data;}catch(error){console.error('Error fetching telemetry:',error);// Handle specific error cases\nif(error.response){if(error.response.status===404){throw new Error('Telemetry data not found');}else if(error.response.status===429){throw new Error('API rate limit exceeded. Please try again later.');}else{var _error$response$data;throw new Error(`API error: ${((_error$response$data=error.response.data)===null||_error$response$data===void 0?void 0:_error$response$data.error)||'Unknown error'}`);}}else if(error.code==='ECONNABORTED'){throw new Error('Request timed out. Telemetry data is large and may take time to load.');}else if(error.code==='ECONNRESET'){throw new Error('Connection reset by server. Please try again later.');}else if(error.request){throw new Error('No response from server. Please check your connection.');}else{throw error;}}},/**\n   * Search for matches based on criteria with improved reliability\n   * @param {Object} criteria - Search criteria\n   * @returns {Promise<Object>} Search results\n   */async searchMatches(criteria){try{// Get auth token if available\nconst token=authService.getToken();// Request headers\nconst headers={};if(token){headers.Authorization=`Bearer ${token}`;}// Implement retry logic with exponential backoff\nlet retries=2;let lastError=null;while(retries>=0){try{console.log(`Searching for matches (attempt ${2-retries+1}/3)`);// Add a timeout to prevent hanging requests\nconst response=await axios.post('/api/matches/search',criteria,{headers,timeout:30000// 30 second timeout for search\n});// Make sure we return the data in the expected format\nreturn response.data;}catch(error){lastError=error;// Don't retry if we've exhausted retries\nif(retries<=0){break;}// Wait before retry (2s, then 4s)\nconst delay=(3-retries)*2000;console.log(`Search failed. Retrying after ${delay}ms...`);await new Promise(resolve=>setTimeout(resolve,delay));retries--;}}// If we reach here, all retries failed\nconsole.error('All search attempts failed:',lastError);// Handle specific error cases\nif(lastError.response){// Server responded with an error status\nif(lastError.response.status===401){throw new Error('Authentication required');}else if(lastError.response.status===429){throw new Error('API rate limit exceeded. Please try again later.');}else{var _lastError$response$d2;throw new Error(`API error: ${((_lastError$response$d2=lastError.response.data)===null||_lastError$response$d2===void 0?void 0:_lastError$response$d2.error)||lastError.response.statusText||'Unknown error'}`);}}else if(lastError.code==='ECONNABORTED'){// Request timed out\nthrow new Error('Request timed out. The server might be overloaded.');}else if(lastError.code==='ECONNRESET'){// Connection reset by server\nthrow new Error('Connection reset by server. Please try again later.');}else if(lastError.request){// No response received\nthrow new Error('No response from server. Please check your connection.');}else{// Something else went wrong\nthrow lastError;}}catch(error){console.error('Error in searchMatches:',error);throw error;}},/**\n   * Register a match to a tournament\n   * @param {Object} matchData - Match registration data\n   * @returns {Promise<Object>} Registration result\n   */async registerMatch(matchData){try{// Get auth token (required for this operation)\nconst token=authService.getToken();if(!token){throw new Error('Authentication required');}// Request headers\nconst headers={Authorization:`Bearer ${token}`};// Make API request with retry logic\nlet retries=2;let lastError=null;while(retries>=0){try{const response=await axios.post('/api/matches/register',matchData,{headers,timeout:10000// 10 second timeout\n});return response.data;}catch(error){lastError=error;// If it's a 404 or 409, don't retry (match not found or already registered)\nif(error.response&&(error.response.status===404||error.response.status===409)){throw error;}// Don't retry if we've exhausted retries\nif(retries<=0){break;}// Wait before retry (1s, then 2s)\nconst delay=(2-retries)*1000+1000;console.log(`Retrying match registration after ${delay}ms...`);await new Promise(resolve=>setTimeout(resolve,delay));retries--;}}// If we reach here, all retries failed\n// Handle specific error cases\nif(lastError.response){// Server responded with an error status\nif(lastError.response.status===401){throw new Error('Authentication required');}else if(lastError.response.status===404){throw new Error('Match not found');}else if(lastError.response.status===409){throw new Error('Match is already registered to a tournament');}else if(lastError.response.status===429){throw new Error('API rate limit exceeded. Please try again later.');}else{var _lastError$response$d3;throw new Error(`API error: ${((_lastError$response$d3=lastError.response.data)===null||_lastError$response$d3===void 0?void 0:_lastError$response$d3.error)||'Unknown error'}`);}}else if(lastError.request){// No response received\nthrow new Error('No response from server. Please check your connection.');}else{// Something else went wrong\nthrow lastError;}}catch(error){console.error('Error registering match:',error);throw error;}}};export default matchesServiceEnhanced;","map":{"version":3,"names":["axios","authService","cacheService","matchesServiceEnhanced","getMatchDetails","matchId","platform","arguments","length","undefined","bypassCache","cachedMatch","getMatch","console","log","token","getToken","headers","Authorization","retries","lastError","response","get","timeout","data","Error","storeMatch","error","status","delay","Promise","resolve","setTimeout","warn","_lastError$response$d","code","request","getTelemetry","telemetryUrl","cacheKey","cachedTelemetry","localStorage","getItem","parsed","JSON","parse","e","removeItem","matchData","included","assets","filter","item","type","_assets$","_assets$$attributes","attributes","URL","setItem","stringify","clearOldCache","_error$response$data","searchMatches","criteria","post","_lastError$response$d2","statusText","registerMatch","_lastError$response$d3"],"sources":["C:/Users/emil/OneDrive/Documents/development/apiDevelopment/pubg-tournament-tracker/client/src/services/matchesServiceEnhanced.js"],"sourcesContent":["import axios from 'axios';\nimport authService from './authService';\nimport cacheService from './cacheService';\n\n// Create a service for handling match-related API calls with enhanced error handling\nconst matchesServiceEnhanced = {\n  /**\n   * Get match details by ID with caching support and better error handling\n   * @param {string} matchId - PUBG match ID\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API even if cached\n   * @returns {Promise<Object>} Match data\n   */\n  async getMatchDetails(matchId, platform = 'steam', bypassCache = false) {\n    try {\n      // First, check if we have this match cached (unless bypass requested)\n      if (!bypassCache) {\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log(`Using cached data for match: ${matchId}`);\n          return cachedMatch;\n        }\n      }\n      \n      // Get auth token if available\n      const token = authService.getToken();\n      \n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // Make API request with retry logic\n      console.log(`Fetching match data from API: ${matchId}`);\n      let retries = 2;\n      let lastError = null;\n      \n      while (retries >= 0) {\n        try {\n          const response = await axios.get(`/api/matches/${matchId}?platform=${platform}`, { \n            headers,\n            timeout: 15000 // 15 second timeout\n          });\n          \n          // If response is empty or missing key attributes, throw an error\n          if (!response.data || !response.data.data) {\n            throw new Error('Invalid response format from API');\n          }\n          \n          // Cache the successful response\n          cacheService.storeMatch(matchId, platform, response.data);\n          \n          return response.data;\n        } catch (error) {\n          lastError = error;\n          \n          // If it's a 404, don't retry\n          if (error.response && error.response.status === 404) {\n            throw new Error('Match not found');\n          }\n          \n          // Don't retry if we've exhausted retries\n          if (retries <= 0) {\n            break;\n          }\n          \n          // Wait before retry (1s, then 2s)\n          const delay = (2 - retries) * 1000 + 1000;\n          console.log(`Retrying after ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n          \n          retries--;\n        }\n      }\n      \n      // If we reach here, all retries failed\n      \n      // Handle specific error cases\n      if (lastError.response) {\n        // Handle rate limit specifically\n        if (lastError.response.status === 429) {\n          console.warn('Rate limit reached for PUBG API, checking cache for fallback');\n          \n          // Check if we have any cached data as fallback\n          const cachedMatch = cacheService.getMatch(matchId, platform);\n          if (cachedMatch) {\n            console.log('Using cached data due to rate limiting');\n            return cachedMatch;\n          }\n          \n          throw new Error('API rate limit exceeded and no cached data available. Please try again later.');\n        } \n        else if (lastError.response.status === 401) {\n          throw new Error('Authentication required');\n        } else {\n          throw new Error(`API error: ${lastError.response.data?.error || 'Unknown error'}`);\n        }\n      } else if (lastError.code === 'ECONNABORTED') {\n        console.warn('Request timeout, checking cache for fallback');\n        // Check cache as fallback\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data due to timeout');\n          return cachedMatch;\n        }\n        throw new Error('Request timed out. The server might be overloaded.');\n      } else if (lastError.code === 'ECONNRESET') {\n        console.warn('Connection reset by server, checking cache for fallback');\n        // Check cache as fallback\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data due to connection reset');\n          return cachedMatch;\n        }\n        throw new Error('Connection reset by server. Please try again later.');\n      } else if (lastError.request) {\n        // No response received, check cache as fallback\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data due to connection issue');\n          return cachedMatch;\n        }\n        \n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw lastError;\n      }\n    } catch (error) {\n      console.error(`Error getting match details: ${matchId}`, error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Get telemetry data for a match with caching\n   * @param {string} matchId - PUBG match ID\n   * @param {string} telemetryUrl - URL to telemetry data (if known)\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API\n   * @returns {Promise<Object>} Telemetry data\n   */\n  async getTelemetry(matchId, telemetryUrl = null, platform = 'steam', bypassCache = false) {\n    const cacheKey = `telemetry_${matchId}`;\n    \n    try {\n      // Check cache first\n      if (!bypassCache) {\n        // We use the regular localStorage for telemetry due to its large size\n        const cachedTelemetry = localStorage.getItem(cacheKey);\n        if (cachedTelemetry) {\n          try {\n            const parsed = JSON.parse(cachedTelemetry);\n            console.log(`Using cached telemetry data for match: ${matchId}`);\n            return parsed;\n          } catch (e) {\n            // Invalid cache, remove it\n            localStorage.removeItem(cacheKey);\n          }\n        }\n      }\n      \n      // Get auth token if available\n      const token = authService.getToken();\n      \n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // We need to get the telemetry URL first if not provided\n      if (!telemetryUrl) {\n        console.log(`Fetching match data to get telemetry URL: ${matchId}`);\n        // Try to get from cache first\n        let matchData = null;\n        \n        try {\n          matchData = await this.getMatchDetails(matchId, platform, bypassCache);\n          \n          // Extract telemetry URL from match data\n          if (matchData.data && matchData.included) {\n            const assets = matchData.included.filter(item => item.type === 'asset');\n            if (assets.length > 0) {\n              telemetryUrl = assets[0]?.attributes?.URL;\n            }\n          }\n        } catch (error) {\n          console.error('Error getting match data for telemetry:', error);\n        }\n        \n        if (!telemetryUrl) {\n          throw new Error('Could not find telemetry URL for this match');\n        }\n      }\n\n      // Make API request to get telemetry data\n      console.log(`Fetching telemetry data for match: ${matchId}`);\n      \n      // Use our server endpoint instead of direct telemetry URL\n      // This helps avoid CORS issues and provides better error handling\n      const response = await axios.get(`/api/telemetry/${matchId}?platform=${platform}`, { \n        headers,\n        timeout: 45000 // Extended timeout for large telemetry files\n      });\n      \n      // Cache the telemetry data\n      try {\n        localStorage.setItem(cacheKey, JSON.stringify(response.data));\n        console.log(`Cached telemetry data for match: ${matchId}`);\n      } catch (e) {\n        // Local storage might be full - telemetry can be very large\n        console.warn('Could not cache telemetry data - likely too large for localStorage');\n        // Try to clear some space\n        cacheService.clearOldCache();\n      }\n      \n      return response.data;\n    } catch (error) {\n      console.error('Error fetching telemetry:', error);\n      \n      // Handle specific error cases\n      if (error.response) {\n        if (error.response.status === 404) {\n          throw new Error('Telemetry data not found');\n        } else if (error.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          throw new Error(`API error: ${error.response.data?.error || 'Unknown error'}`);\n        }\n      } else if (error.code === 'ECONNABORTED') {\n        throw new Error('Request timed out. Telemetry data is large and may take time to load.');\n      } else if (error.code === 'ECONNRESET') {\n        throw new Error('Connection reset by server. Please try again later.');\n      } else if (error.request) {\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        throw error;\n      }\n    }\n  },\n  \n  /**\n   * Search for matches based on criteria with improved reliability\n   * @param {Object} criteria - Search criteria\n   * @returns {Promise<Object>} Search results\n   */\n  async searchMatches(criteria) {\n    try {\n      // Get auth token if available\n      const token = authService.getToken();\n      \n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // Implement retry logic with exponential backoff\n      let retries = 2;\n      let lastError = null;\n      \n      while (retries >= 0) {\n        try {\n          console.log(`Searching for matches (attempt ${2 - retries + 1}/3)`);\n          \n          // Add a timeout to prevent hanging requests\n          const response = await axios.post('/api/matches/search', criteria, { \n            headers,\n            timeout: 30000 // 30 second timeout for search\n          });\n          \n          // Make sure we return the data in the expected format\n          return response.data;\n        } catch (error) {\n          lastError = error;\n          \n          // Don't retry if we've exhausted retries\n          if (retries <= 0) {\n            break;\n          }\n          \n          // Wait before retry (2s, then 4s)\n          const delay = (3 - retries) * 2000;\n          console.log(`Search failed. Retrying after ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n          \n          retries--;\n        }\n      }\n      \n      // If we reach here, all retries failed\n      console.error('All search attempts failed:', lastError);\n      \n      // Handle specific error cases\n      if (lastError.response) {\n        // Server responded with an error status\n        if (lastError.response.status === 401) {\n          throw new Error('Authentication required');\n        } else if (lastError.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          throw new Error(`API error: ${lastError.response.data?.error || lastError.response.statusText || 'Unknown error'}`);\n        }\n      } else if (lastError.code === 'ECONNABORTED') {\n        // Request timed out\n        throw new Error('Request timed out. The server might be overloaded.');\n      } else if (lastError.code === 'ECONNRESET') {\n        // Connection reset by server\n        throw new Error('Connection reset by server. Please try again later.');\n      } else if (lastError.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw lastError;\n      }\n    } catch (error) {\n      console.error('Error in searchMatches:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Register a match to a tournament\n   * @param {Object} matchData - Match registration data\n   * @returns {Promise<Object>} Registration result\n   */\n  async registerMatch(matchData) {\n    try {\n      // Get auth token (required for this operation)\n      const token = authService.getToken();\n      if (!token) {\n        throw new Error('Authentication required');\n      }\n      \n      // Request headers\n      const headers = {\n        Authorization: `Bearer ${token}`\n      };\n\n      // Make API request with retry logic\n      let retries = 2;\n      let lastError = null;\n      \n      while (retries >= 0) {\n        try {\n          const response = await axios.post('/api/matches/register', matchData, { \n            headers,\n            timeout: 10000 // 10 second timeout\n          });\n          \n          return response.data;\n        } catch (error) {\n          lastError = error;\n          \n          // If it's a 404 or 409, don't retry (match not found or already registered)\n          if (error.response && (error.response.status === 404 || error.response.status === 409)) {\n            throw error;\n          }\n          \n          // Don't retry if we've exhausted retries\n          if (retries <= 0) {\n            break;\n          }\n          \n          // Wait before retry (1s, then 2s)\n          const delay = (2 - retries) * 1000 + 1000;\n          console.log(`Retrying match registration after ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n          \n          retries--;\n        }\n      }\n      \n      // If we reach here, all retries failed\n      // Handle specific error cases\n      if (lastError.response) {\n        // Server responded with an error status\n        if (lastError.response.status === 401) {\n          throw new Error('Authentication required');\n        } else if (lastError.response.status === 404) {\n          throw new Error('Match not found');\n        } else if (lastError.response.status === 409) {\n          throw new Error('Match is already registered to a tournament');\n        } else if (lastError.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          throw new Error(`API error: ${lastError.response.data?.error || 'Unknown error'}`);\n        }\n      } else if (lastError.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw lastError;\n      }\n    } catch (error) {\n      console.error('Error registering match:', error);\n      throw error;\n    }\n  }\n};\n\nexport default matchesServiceEnhanced;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}