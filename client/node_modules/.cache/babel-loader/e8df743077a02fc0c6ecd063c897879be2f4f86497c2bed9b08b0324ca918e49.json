{"ast":null,"code":"/**\n * Match utility functions for formatting and processing match data\n */\n\n/**\n * Get match type (RANKED, CUSTOM, or PUBLIC)\n * @param {Object} match - Match data from API\n * @returns {string} Match type\n */\nexport const getMatchType = match => {\n  var _match$meta;\n  if (!match || !match.data || !match.data.attributes) {\n    return 'UNKNOWN';\n  }\n  const attributes = match.data.attributes;\n\n  // Check for meta data first\n  if ((_match$meta = match.meta) !== null && _match$meta !== void 0 && _match$meta.matchType) {\n    return match.meta.matchType;\n  }\n\n  // Use the matchType attribute as the primary classification method\n  if (attributes.matchType === 'competitive') {\n    return 'RANKED';\n  } else if (attributes.matchType === 'custom' || attributes.isCustomMatch === true) {\n    return 'CUSTOM';\n  } else if (attributes.matchType === 'official') {\n    return 'PUBLIC';\n  }\n\n  // Fall back to checking other attributes\n  if (attributes.seasonState === 'progress' && attributes.gameMode === 'squad-fpp') {\n    return 'RANKED';\n  }\n\n  // Default to PUBLIC if can't determine\n  return 'PUBLIC';\n};\n\n/**\n * Get human-readable description of match type\n * @param {string} matchType - Match type code\n * @returns {string} Human-readable description\n */\nexport const getMatchTypeDescription = matchType => {\n  switch (matchType) {\n    case 'RANKED':\n      return 'Ranked Match';\n    case 'CUSTOM':\n      return 'Custom Match';\n    case 'PUBLIC':\n      return 'Public Match';\n    default:\n      return 'Unknown Match Type';\n  }\n};\n\n/**\n * Format match date to human-readable string\n * @param {string} dateString - ISO date string\n * @returns {string} Formatted date string\n */\nexport const formatMatchDate = dateString => {\n  try {\n    const date = new Date(dateString);\n    return date.toLocaleString('en-US', {\n      month: 'short',\n      day: 'numeric',\n      year: 'numeric',\n      hour: 'numeric',\n      minute: '2-digit',\n      hour12: true\n    });\n  } catch (error) {\n    console.error('Error formatting date:', error);\n    return dateString || 'Unknown Date';\n  }\n};\n\n/**\n * Format match duration in seconds to MM:SS format\n * @param {number} durationSeconds - Duration in seconds\n * @returns {string} Formatted duration\n */\nexport const formatMatchDuration = durationSeconds => {\n  if (!durationSeconds) return '00:00';\n  const minutes = Math.floor(durationSeconds / 60);\n  const seconds = durationSeconds % 60;\n  return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n};\n\n/**\n * Get relative time string from date\n * @param {string} dateString - ISO date string\n * @returns {string} Relative time string (e.g., \"2 hours ago\")\n */\nexport const getRelativeTime = dateString => {\n  try {\n    const date = new Date(dateString);\n    const now = new Date();\n    const diffMs = now - date;\n    const diffSec = Math.round(diffMs / 1000);\n    const diffMin = Math.round(diffSec / 60);\n    const diffHour = Math.round(diffMin / 60);\n    const diffDay = Math.round(diffHour / 24);\n    if (diffSec < 60) {\n      return 'just now';\n    } else if (diffMin < 60) {\n      return `${diffMin} minute${diffMin !== 1 ? 's' : ''} ago`;\n    } else if (diffHour < 24) {\n      return `${diffHour} hour${diffHour !== 1 ? 's' : ''} ago`;\n    } else if (diffDay < 30) {\n      return `${diffDay} day${diffDay !== 1 ? 's' : ''} ago`;\n    } else {\n      return formatMatchDate(dateString);\n    }\n  } catch (error) {\n    console.error('Error calculating relative time:', error);\n    return dateString || 'Unknown Date';\n  }\n};\n\n/**\n * Get map name from PUBG map code\n * @param {string} mapCode - PUBG map code\n * @returns {string} Human-readable map name\n */\nexport const getMapName = mapCode => {\n  const mapNames = {\n    'Baltic_Main': 'Erangel',\n    'Erangel_Main': 'Erangel',\n    'Desert_Main': 'Miramar',\n    'Savage_Main': 'Sanhok',\n    'DihorOtok_Main': 'Vikendi',\n    'Range_Main': 'Camp Jackal',\n    'Summerland_Main': 'Karakin',\n    'Tiger_Main': 'Taego',\n    'Kiki_Main': 'Deston',\n    'Heaven_Main': 'Paramo',\n    'Chimera_Main': 'Haven'\n  };\n  return mapNames[mapCode] || mapCode || 'Unknown Map';\n};\n\n/**\n * Get game mode description from PUBG game mode code\n * @param {string} gameMode - PUBG game mode code\n * @returns {string} Human-readable game mode\n */\nexport const getGameModeDescription = gameMode => {\n  if (!gameMode) return 'Unknown Mode';\n\n  // Check for perspective (TPP or FPP)\n  const isFPP = gameMode.includes('fpp');\n  const perspective = isFPP ? 'FPP' : 'TPP';\n\n  // Get squad size\n  let squadType = 'Solo';\n  if (gameMode.includes('squad')) {\n    squadType = 'Squad';\n  } else if (gameMode.includes('duo')) {\n    squadType = 'Duo';\n  }\n\n  // Check if it's a ranked mode\n  const isRanked = gameMode.includes('ranked') || gameMode.includes('competitive');\n  const rankedPrefix = isRanked ? 'Ranked ' : '';\n  return `${rankedPrefix}${squadType} ${perspective}`;\n};\n\n/**\n * Get color for damage value (low: green, medium: yellow, high: red)\n * @param {number} damage - Damage value\n * @returns {string} CSS color value\n */\nexport const getDamageColor = damage => {\n  if (damage >= 500) return '#ff4d4d'; // High damage (red)\n  if (damage >= 300) return '#ffa64d'; // Medium-high damage (orange)\n  if (damage >= 150) return '#ffff4d'; // Medium damage (yellow)\n  if (damage >= 75) return '#4dff4d'; // Medium-low damage (green)\n  return '#4da6ff'; // Low damage (blue)\n};\n\n/**\n * Check if a match is a custom match\n * @param {Object} match - Match data\n * @returns {boolean} True if it's a custom match\n */\nexport const isCustomMatch = match => {\n  var _match$meta2;\n  if (!match || !match.data || !match.data.attributes) {\n    return false;\n  }\n  const attributes = match.data.attributes;\n\n  // Direct attribute check\n  if (attributes.matchType === 'custom' || attributes.isCustomMatch === true) {\n    return true;\n  }\n\n  // Check meta data if available\n  if (((_match$meta2 = match.meta) === null || _match$meta2 === void 0 ? void 0 : _match$meta2.isCustomMatch) === true) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Check if a match is a ranked match\n * @param {Object} match - Match data\n * @returns {boolean} True if it's a ranked match\n */\nexport const isRankedMatch = match => {\n  var _match$meta3;\n  if (!match || !match.data || !match.data.attributes) {\n    return false;\n  }\n  const attributes = match.data.attributes;\n\n  // Direct attribute check\n  if (attributes.matchType === 'competitive') {\n    return true;\n  }\n\n  // Check meta data if available\n  if (((_match$meta3 = match.meta) === null || _match$meta3 === void 0 ? void 0 : _match$meta3.isRankedMatch) === true) {\n    return true;\n  }\n\n  // Check other indicators\n  if (attributes.seasonState === 'progress' && attributes.gameMode === 'squad-fpp') {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Get CSS class for a match type\n * @param {string} matchType - Match type code\n * @returns {string} CSS class name\n */\nexport const getMatchTypeClass = matchType => {\n  if (!matchType) return 'unknown-match';\n  switch (matchType.toUpperCase()) {\n    case 'RANKED':\n      return 'ranked-match';\n    case 'CUSTOM':\n      return 'custom-match';\n    case 'PUBLIC':\n      return 'public-match';\n    default:\n      return 'unknown-match';\n  }\n};","map":{"version":3,"names":["getMatchType","match","_match$meta","data","attributes","meta","matchType","isCustomMatch","seasonState","gameMode","getMatchTypeDescription","formatMatchDate","dateString","date","Date","toLocaleString","month","day","year","hour","minute","hour12","error","console","formatMatchDuration","durationSeconds","minutes","Math","floor","seconds","toString","padStart","getRelativeTime","now","diffMs","diffSec","round","diffMin","diffHour","diffDay","getMapName","mapCode","mapNames","getGameModeDescription","isFPP","includes","perspective","squadType","isRanked","rankedPrefix","getDamageColor","damage","_match$meta2","isRankedMatch","_match$meta3","getMatchTypeClass","toUpperCase"],"sources":["C:/Users/emil/OneDrive/Documents/development/apiDevelopment/pubg-tournament-tracker/client/src/utils/matchUtils.js"],"sourcesContent":["/**\n * Match utility functions for formatting and processing match data\n */\n\n/**\n * Get match type (RANKED, CUSTOM, or PUBLIC)\n * @param {Object} match - Match data from API\n * @returns {string} Match type\n */\nexport const getMatchType = (match) => {\n  if (!match || !match.data || !match.data.attributes) {\n    return 'UNKNOWN';\n  }\n  \n  const attributes = match.data.attributes;\n  \n  // Check for meta data first\n  if (match.meta?.matchType) {\n    return match.meta.matchType;\n  }\n  \n  // Use the matchType attribute as the primary classification method\n  if (attributes.matchType === 'competitive') {\n    return 'RANKED';\n  } else if (attributes.matchType === 'custom' || attributes.isCustomMatch === true) {\n    return 'CUSTOM';\n  } else if (attributes.matchType === 'official') {\n    return 'PUBLIC';\n  }\n  \n  // Fall back to checking other attributes\n  if (attributes.seasonState === 'progress' && attributes.gameMode === 'squad-fpp') {\n    return 'RANKED';\n  }\n  \n  // Default to PUBLIC if can't determine\n  return 'PUBLIC';\n};\n\n/**\n * Get human-readable description of match type\n * @param {string} matchType - Match type code\n * @returns {string} Human-readable description\n */\nexport const getMatchTypeDescription = (matchType) => {\n  switch (matchType) {\n    case 'RANKED':\n      return 'Ranked Match';\n    case 'CUSTOM':\n      return 'Custom Match';\n    case 'PUBLIC':\n      return 'Public Match';\n    default:\n      return 'Unknown Match Type';\n  }\n};\n\n/**\n * Format match date to human-readable string\n * @param {string} dateString - ISO date string\n * @returns {string} Formatted date string\n */\nexport const formatMatchDate = (dateString) => {\n  try {\n    const date = new Date(dateString);\n    return date.toLocaleString('en-US', {\n      month: 'short',\n      day: 'numeric',\n      year: 'numeric',\n      hour: 'numeric',\n      minute: '2-digit',\n      hour12: true\n    });\n  } catch (error) {\n    console.error('Error formatting date:', error);\n    return dateString || 'Unknown Date';\n  }\n};\n\n/**\n * Format match duration in seconds to MM:SS format\n * @param {number} durationSeconds - Duration in seconds\n * @returns {string} Formatted duration\n */\nexport const formatMatchDuration = (durationSeconds) => {\n  if (!durationSeconds) return '00:00';\n  \n  const minutes = Math.floor(durationSeconds / 60);\n  const seconds = durationSeconds % 60;\n  \n  return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n};\n\n/**\n * Get relative time string from date\n * @param {string} dateString - ISO date string\n * @returns {string} Relative time string (e.g., \"2 hours ago\")\n */\nexport const getRelativeTime = (dateString) => {\n  try {\n    const date = new Date(dateString);\n    const now = new Date();\n    const diffMs = now - date;\n    const diffSec = Math.round(diffMs / 1000);\n    const diffMin = Math.round(diffSec / 60);\n    const diffHour = Math.round(diffMin / 60);\n    const diffDay = Math.round(diffHour / 24);\n    \n    if (diffSec < 60) {\n      return 'just now';\n    } else if (diffMin < 60) {\n      return `${diffMin} minute${diffMin !== 1 ? 's' : ''} ago`;\n    } else if (diffHour < 24) {\n      return `${diffHour} hour${diffHour !== 1 ? 's' : ''} ago`;\n    } else if (diffDay < 30) {\n      return `${diffDay} day${diffDay !== 1 ? 's' : ''} ago`;\n    } else {\n      return formatMatchDate(dateString);\n    }\n  } catch (error) {\n    console.error('Error calculating relative time:', error);\n    return dateString || 'Unknown Date';\n  }\n};\n\n/**\n * Get map name from PUBG map code\n * @param {string} mapCode - PUBG map code\n * @returns {string} Human-readable map name\n */\nexport const getMapName = (mapCode) => {\n  const mapNames = {\n    'Baltic_Main': 'Erangel',\n    'Erangel_Main': 'Erangel',\n    'Desert_Main': 'Miramar',\n    'Savage_Main': 'Sanhok',\n    'DihorOtok_Main': 'Vikendi',\n    'Range_Main': 'Camp Jackal',\n    'Summerland_Main': 'Karakin',\n    'Tiger_Main': 'Taego',\n    'Kiki_Main': 'Deston',\n    'Heaven_Main': 'Paramo',\n    'Chimera_Main': 'Haven'\n  };\n  \n  return mapNames[mapCode] || mapCode || 'Unknown Map';\n};\n\n/**\n * Get game mode description from PUBG game mode code\n * @param {string} gameMode - PUBG game mode code\n * @returns {string} Human-readable game mode\n */\nexport const getGameModeDescription = (gameMode) => {\n  if (!gameMode) return 'Unknown Mode';\n  \n  // Check for perspective (TPP or FPP)\n  const isFPP = gameMode.includes('fpp');\n  const perspective = isFPP ? 'FPP' : 'TPP';\n  \n  // Get squad size\n  let squadType = 'Solo';\n  if (gameMode.includes('squad')) {\n    squadType = 'Squad';\n  } else if (gameMode.includes('duo')) {\n    squadType = 'Duo';\n  }\n  \n  // Check if it's a ranked mode\n  const isRanked = gameMode.includes('ranked') || gameMode.includes('competitive');\n  const rankedPrefix = isRanked ? 'Ranked ' : '';\n  \n  return `${rankedPrefix}${squadType} ${perspective}`;\n};\n\n/**\n * Get color for damage value (low: green, medium: yellow, high: red)\n * @param {number} damage - Damage value\n * @returns {string} CSS color value\n */\nexport const getDamageColor = (damage) => {\n  if (damage >= 500) return '#ff4d4d'; // High damage (red)\n  if (damage >= 300) return '#ffa64d'; // Medium-high damage (orange)\n  if (damage >= 150) return '#ffff4d'; // Medium damage (yellow)\n  if (damage >= 75) return '#4dff4d';  // Medium-low damage (green)\n  return '#4da6ff';                    // Low damage (blue)\n};\n\n/**\n * Check if a match is a custom match\n * @param {Object} match - Match data\n * @returns {boolean} True if it's a custom match\n */\nexport const isCustomMatch = (match) => {\n  if (!match || !match.data || !match.data.attributes) {\n    return false;\n  }\n  \n  const attributes = match.data.attributes;\n  \n  // Direct attribute check\n  if (attributes.matchType === 'custom' || attributes.isCustomMatch === true) {\n    return true;\n  }\n  \n  // Check meta data if available\n  if (match.meta?.isCustomMatch === true) {\n    return true;\n  }\n  \n  return false;\n};\n\n/**\n * Check if a match is a ranked match\n * @param {Object} match - Match data\n * @returns {boolean} True if it's a ranked match\n */\nexport const isRankedMatch = (match) => {\n  if (!match || !match.data || !match.data.attributes) {\n    return false;\n  }\n  \n  const attributes = match.data.attributes;\n  \n  // Direct attribute check\n  if (attributes.matchType === 'competitive') {\n    return true;\n  }\n  \n  // Check meta data if available\n  if (match.meta?.isRankedMatch === true) {\n    return true;\n  }\n  \n  // Check other indicators\n  if (attributes.seasonState === 'progress' && attributes.gameMode === 'squad-fpp') {\n    return true;\n  }\n  \n  return false;\n};\n\n/**\n * Get CSS class for a match type\n * @param {string} matchType - Match type code\n * @returns {string} CSS class name\n */\nexport const getMatchTypeClass = (matchType) => {\n  if (!matchType) return 'unknown-match';\n  \n  switch (matchType.toUpperCase()) {\n    case 'RANKED':\n      return 'ranked-match';\n    case 'CUSTOM':\n      return 'custom-match';\n    case 'PUBLIC':\n      return 'public-match';\n    default:\n      return 'unknown-match';\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}