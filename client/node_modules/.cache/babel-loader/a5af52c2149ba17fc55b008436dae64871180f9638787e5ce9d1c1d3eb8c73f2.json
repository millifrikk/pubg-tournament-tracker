{"ast":null,"code":"// cacheService.js - Local storage based caching for PUBG match data\nconst CACHE_PREFIX='pubg_match_';const CACHE_EXPIRY=7*24*60*60*1000;// 7 days in milliseconds\nexport const cacheService={/**\n   * Store match data in localStorage\n   * @param {string} matchId - PUBG match ID\n   * @param {string} platform - Platform (steam, xbox, etc.)\n   * @param {Object} data - Match data to cache\n   * @returns {boolean} Success status\n   */storeMatch(matchId,platform,data){try{const cacheKey=`${CACHE_PREFIX}${platform}_${matchId}`;const cacheData={data:data,timestamp:Date.now(),expires:Date.now()+CACHE_EXPIRY};localStorage.setItem(cacheKey,JSON.stringify(cacheData));console.log(`Cached match data for: ${matchId}`);return true;}catch(error){console.error('Error storing match in cache:',error);// If localStorage is full, try to clear older items\nif(error instanceof DOMException&&error.name==='QuotaExceededError'){this.clearOldCache();}return false;}},/**\n   * Get match data from localStorage if available and not expired\n   * @param {string} matchId - PUBG match ID\n   * @param {string} platform - Platform (steam, xbox, etc.)\n   * @returns {Object|null} Cached match data or null\n   */getMatch(matchId,platform){try{const cacheKey=`${CACHE_PREFIX}${platform}_${matchId}`;const cachedData=localStorage.getItem(cacheKey);if(!cachedData)return null;const parsed=JSON.parse(cachedData);// Check if cache is expired (technically unnecessary for match data since it's immutable,\n// but good practice for cache management)\nif(parsed.expires<Date.now()){localStorage.removeItem(cacheKey);return null;}return parsed.data;}catch(error){console.error('Error retrieving match from cache:',error);return null;}},/**\n   * Clear expired or old cache entries\n   */clearOldCache(){try{// Get all keys in localStorage that match our cache prefix\nconst keys=[];for(let i=0;i<localStorage.length;i++){const key=localStorage.key(i);if(key&&key.startsWith(CACHE_PREFIX)){keys.push(key);}}// Find expired or old items\nconst now=Date.now();const itemsToRemove=[];keys.forEach(key=>{try{const value=localStorage.getItem(key);if(value){const parsed=JSON.parse(value);// Remove if expired or older than half the expiry time\nif(parsed.expires<now||now-parsed.timestamp>CACHE_EXPIRY/2){itemsToRemove.push(key);}}else{// Invalid item\nitemsToRemove.push(key);}}catch(e){// If we can't parse it, it's corrupted\nitemsToRemove.push(key);}});// Remove old/expired items\nitemsToRemove.forEach(key=>{localStorage.removeItem(key);});console.log(`Cleared ${itemsToRemove.length} old cache entries`);}catch(error){console.error('Error clearing old cache:',error);}}};export default cacheService;","map":{"version":3,"names":["CACHE_PREFIX","CACHE_EXPIRY","cacheService","storeMatch","matchId","platform","data","cacheKey","cacheData","timestamp","Date","now","expires","localStorage","setItem","JSON","stringify","console","log","error","DOMException","name","clearOldCache","getMatch","cachedData","getItem","parsed","parse","removeItem","keys","i","length","key","startsWith","push","itemsToRemove","forEach","value","e"],"sources":["C:/Users/emil/OneDrive/Documents/development/apiDevelopment/pubg-tournament-tracker/client/src/services/cacheService.js"],"sourcesContent":["// cacheService.js - Local storage based caching for PUBG match data\nconst CACHE_PREFIX = 'pubg_match_';\nconst CACHE_EXPIRY = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\n\nexport const cacheService = {\n  /**\n   * Store match data in localStorage\n   * @param {string} matchId - PUBG match ID\n   * @param {string} platform - Platform (steam, xbox, etc.)\n   * @param {Object} data - Match data to cache\n   * @returns {boolean} Success status\n   */\n  storeMatch(matchId, platform, data) {\n    try {\n      const cacheKey = `${CACHE_PREFIX}${platform}_${matchId}`;\n      const cacheData = {\n        data: data,\n        timestamp: Date.now(),\n        expires: Date.now() + CACHE_EXPIRY\n      };\n      localStorage.setItem(cacheKey, JSON.stringify(cacheData));\n      console.log(`Cached match data for: ${matchId}`);\n      return true;\n    } catch (error) {\n      console.error('Error storing match in cache:', error);\n      // If localStorage is full, try to clear older items\n      if (error instanceof DOMException && error.name === 'QuotaExceededError') {\n        this.clearOldCache();\n      }\n      return false;\n    }\n  },\n\n  /**\n   * Get match data from localStorage if available and not expired\n   * @param {string} matchId - PUBG match ID\n   * @param {string} platform - Platform (steam, xbox, etc.)\n   * @returns {Object|null} Cached match data or null\n   */\n  getMatch(matchId, platform) {\n    try {\n      const cacheKey = `${CACHE_PREFIX}${platform}_${matchId}`;\n      const cachedData = localStorage.getItem(cacheKey);\n      \n      if (!cachedData) return null;\n      \n      const parsed = JSON.parse(cachedData);\n      \n      // Check if cache is expired (technically unnecessary for match data since it's immutable,\n      // but good practice for cache management)\n      if (parsed.expires < Date.now()) {\n        localStorage.removeItem(cacheKey);\n        return null;\n      }\n      \n      return parsed.data;\n    } catch (error) {\n      console.error('Error retrieving match from cache:', error);\n      return null;\n    }\n  },\n  \n  /**\n   * Clear expired or old cache entries\n   */\n  clearOldCache() {\n    try {\n      // Get all keys in localStorage that match our cache prefix\n      const keys = [];\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && key.startsWith(CACHE_PREFIX)) {\n          keys.push(key);\n        }\n      }\n      \n      // Find expired or old items\n      const now = Date.now();\n      const itemsToRemove = [];\n      \n      keys.forEach(key => {\n        try {\n          const value = localStorage.getItem(key);\n          if (value) {\n            const parsed = JSON.parse(value);\n            // Remove if expired or older than half the expiry time\n            if (parsed.expires < now || (now - parsed.timestamp) > (CACHE_EXPIRY / 2)) {\n              itemsToRemove.push(key);\n            }\n          } else {\n            // Invalid item\n            itemsToRemove.push(key);\n          }\n        } catch (e) {\n          // If we can't parse it, it's corrupted\n          itemsToRemove.push(key);\n        }\n      });\n      \n      // Remove old/expired items\n      itemsToRemove.forEach(key => {\n        localStorage.removeItem(key);\n      });\n      \n      console.log(`Cleared ${itemsToRemove.length} old cache entries`);\n    } catch (error) {\n      console.error('Error clearing old cache:', error);\n    }\n  }\n};\n\nexport default cacheService;"],"mappings":"AAAA;AACA,KAAM,CAAAA,YAAY,CAAG,aAAa,CAClC,KAAM,CAAAC,YAAY,CAAG,CAAC,CAAG,EAAE,CAAG,EAAE,CAAG,EAAE,CAAG,IAAI,CAAE;AAE9C,MAAO,MAAM,CAAAC,YAAY,CAAG,CAC1B;AACF;AACA;AACA;AACA;AACA;AACA,KACEC,UAAUA,CAACC,OAAO,CAAEC,QAAQ,CAAEC,IAAI,CAAE,CAClC,GAAI,CACF,KAAM,CAAAC,QAAQ,CAAG,GAAGP,YAAY,GAAGK,QAAQ,IAAID,OAAO,EAAE,CACxD,KAAM,CAAAI,SAAS,CAAG,CAChBF,IAAI,CAAEA,IAAI,CACVG,SAAS,CAAEC,IAAI,CAACC,GAAG,CAAC,CAAC,CACrBC,OAAO,CAAEF,IAAI,CAACC,GAAG,CAAC,CAAC,CAAGV,YACxB,CAAC,CACDY,YAAY,CAACC,OAAO,CAACP,QAAQ,CAAEQ,IAAI,CAACC,SAAS,CAACR,SAAS,CAAC,CAAC,CACzDS,OAAO,CAACC,GAAG,CAAC,0BAA0Bd,OAAO,EAAE,CAAC,CAChD,MAAO,KAAI,CACb,CAAE,MAAOe,KAAK,CAAE,CACdF,OAAO,CAACE,KAAK,CAAC,+BAA+B,CAAEA,KAAK,CAAC,CACrD;AACA,GAAIA,KAAK,WAAY,CAAAC,YAAY,EAAID,KAAK,CAACE,IAAI,GAAK,oBAAoB,CAAE,CACxE,IAAI,CAACC,aAAa,CAAC,CAAC,CACtB,CACA,MAAO,MAAK,CACd,CACF,CAAC,CAED;AACF;AACA;AACA;AACA;AACA,KACEC,QAAQA,CAACnB,OAAO,CAAEC,QAAQ,CAAE,CAC1B,GAAI,CACF,KAAM,CAAAE,QAAQ,CAAG,GAAGP,YAAY,GAAGK,QAAQ,IAAID,OAAO,EAAE,CACxD,KAAM,CAAAoB,UAAU,CAAGX,YAAY,CAACY,OAAO,CAAClB,QAAQ,CAAC,CAEjD,GAAI,CAACiB,UAAU,CAAE,MAAO,KAAI,CAE5B,KAAM,CAAAE,MAAM,CAAGX,IAAI,CAACY,KAAK,CAACH,UAAU,CAAC,CAErC;AACA;AACA,GAAIE,MAAM,CAACd,OAAO,CAAGF,IAAI,CAACC,GAAG,CAAC,CAAC,CAAE,CAC/BE,YAAY,CAACe,UAAU,CAACrB,QAAQ,CAAC,CACjC,MAAO,KAAI,CACb,CAEA,MAAO,CAAAmB,MAAM,CAACpB,IAAI,CACpB,CAAE,MAAOa,KAAK,CAAE,CACdF,OAAO,CAACE,KAAK,CAAC,oCAAoC,CAAEA,KAAK,CAAC,CAC1D,MAAO,KAAI,CACb,CACF,CAAC,CAED;AACF;AACA,KACEG,aAAaA,CAAA,CAAG,CACd,GAAI,CACF;AACA,KAAM,CAAAO,IAAI,CAAG,EAAE,CACf,IAAK,GAAI,CAAAC,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGjB,YAAY,CAACkB,MAAM,CAAED,CAAC,EAAE,CAAE,CAC5C,KAAM,CAAAE,GAAG,CAAGnB,YAAY,CAACmB,GAAG,CAACF,CAAC,CAAC,CAC/B,GAAIE,GAAG,EAAIA,GAAG,CAACC,UAAU,CAACjC,YAAY,CAAC,CAAE,CACvC6B,IAAI,CAACK,IAAI,CAACF,GAAG,CAAC,CAChB,CACF,CAEA;AACA,KAAM,CAAArB,GAAG,CAAGD,IAAI,CAACC,GAAG,CAAC,CAAC,CACtB,KAAM,CAAAwB,aAAa,CAAG,EAAE,CAExBN,IAAI,CAACO,OAAO,CAACJ,GAAG,EAAI,CAClB,GAAI,CACF,KAAM,CAAAK,KAAK,CAAGxB,YAAY,CAACY,OAAO,CAACO,GAAG,CAAC,CACvC,GAAIK,KAAK,CAAE,CACT,KAAM,CAAAX,MAAM,CAAGX,IAAI,CAACY,KAAK,CAACU,KAAK,CAAC,CAChC;AACA,GAAIX,MAAM,CAACd,OAAO,CAAGD,GAAG,EAAKA,GAAG,CAAGe,MAAM,CAACjB,SAAS,CAAKR,YAAY,CAAG,CAAE,CAAE,CACzEkC,aAAa,CAACD,IAAI,CAACF,GAAG,CAAC,CACzB,CACF,CAAC,IAAM,CACL;AACAG,aAAa,CAACD,IAAI,CAACF,GAAG,CAAC,CACzB,CACF,CAAE,MAAOM,CAAC,CAAE,CACV;AACAH,aAAa,CAACD,IAAI,CAACF,GAAG,CAAC,CACzB,CACF,CAAC,CAAC,CAEF;AACAG,aAAa,CAACC,OAAO,CAACJ,GAAG,EAAI,CAC3BnB,YAAY,CAACe,UAAU,CAACI,GAAG,CAAC,CAC9B,CAAC,CAAC,CAEFf,OAAO,CAACC,GAAG,CAAC,WAAWiB,aAAa,CAACJ,MAAM,oBAAoB,CAAC,CAClE,CAAE,MAAOZ,KAAK,CAAE,CACdF,OAAO,CAACE,KAAK,CAAC,2BAA2B,CAAEA,KAAK,CAAC,CACnD,CACF,CACF,CAAC,CAED,cAAe,CAAAjB,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}