{"ast":null,"code":"import axios from 'axios';\nimport authService from './authService';\nimport cacheService from './cacheService';\n\n// Create a service for handling match-related API calls with enhanced error handling\nconst matchesServiceEnhanced = {\n  /**\n   * Get match details by ID with caching support\n   * @param {string} matchId - PUBG match ID\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API even if cached\n   * @returns {Promise<Object>} Match data\n   */\n  async getMatchDetails(matchId, platform = 'steam', bypassCache = false) {\n    try {\n      // First, check if we have this match cached (unless bypass requested)\n      if (!bypassCache) {\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log(`Using cached data for match: ${matchId}`);\n          return cachedMatch;\n        }\n      }\n\n      // Get auth token if available\n      const token = authService.getToken();\n\n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // Try the lite endpoint first for speed\n      try {\n        console.log(`Trying lite endpoint for match: ${matchId}`);\n        const liteResponse = await axios.get(`/api/matches-lite/${matchId}?platform=${platform}`, {\n          headers,\n          timeout: 5000 // Short timeout for lite endpoint\n        });\n        if (liteResponse.data && liteResponse.data.data) {\n          console.log(`Successfully retrieved match from lite endpoint: ${matchId}`);\n          // Cache the successful response\n          cacheService.storeMatch(matchId, platform, liteResponse.data);\n          return liteResponse.data;\n        }\n      } catch (liteError) {\n        // If lite endpoint fails, proceed to regular endpoint\n        console.log(`Lite endpoint failed, trying regular endpoint for match: ${matchId}`);\n      }\n\n      // Make regular API request\n      console.log(`Fetching match data from API: ${matchId}`);\n      const response = await axios.get(`/api/matches/${matchId}?platform=${platform}`, {\n        headers,\n        timeout: 15000 // 15 second timeout for regular API\n      });\n\n      // If response is empty or missing key attributes, throw an error\n      if (!response.data || !response.data.data) {\n        throw new Error('Invalid response format from API');\n      }\n\n      // Cache the successful response\n      cacheService.storeMatch(matchId, platform, response.data);\n      return response.data;\n    } catch (error) {\n      // Handle specific error cases\n      if (error.response) {\n        // Handle rate limit specifically\n        if (error.response.status === 429) {\n          console.warn('Rate limit reached for PUBG API, checking cache for fallback');\n\n          // Check if we have any cached data as fallback\n          const cachedMatch = cacheService.getMatch(matchId, platform);\n          if (cachedMatch) {\n            console.log('Using cached data due to rate limiting');\n            return cachedMatch;\n          }\n          throw new Error('API rate limit exceeded and no cached data available. Please try again later.');\n        } else if (error.response.status === 404) {\n          throw new Error('Match not found');\n        } else if (error.response.status === 401) {\n          throw new Error('Authentication required');\n        } else {\n          var _error$response$data;\n          throw new Error(`API error: ${((_error$response$data = error.response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.error) || 'Unknown error'}`);\n        }\n      } else if (error.code === 'ECONNABORTED') {\n        console.warn('Request timeout, checking cache for fallback');\n        // Check cache as fallback\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data due to timeout');\n          return cachedMatch;\n        }\n        throw new Error('Request timed out. The server might be overloaded.');\n      } else if (error.code === 'ECONNRESET') {\n        console.warn('Connection reset by server, checking cache for fallback');\n        // Check cache as fallback\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data due to connection reset');\n          return cachedMatch;\n        }\n        throw new Error('Connection reset by server. Please try again later.');\n      } else if (error.request) {\n        // No response received, check cache as fallback\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data due to connection issue');\n          return cachedMatch;\n        }\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw error;\n      }\n    }\n  },\n  /**\n   * Get telemetry data for a match with caching\n   * @param {string} matchId - PUBG match ID\n   * @param {string} telemetryUrl - URL to telemetry data (if known)\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API\n   * @returns {Promise<Object>} Telemetry data\n   */\n  async getTelemetry(matchId, telemetryUrl = null, platform = 'steam', bypassCache = false) {\n    const cacheKey = `telemetry_${matchId}`;\n    try {\n      // Check cache first\n      if (!bypassCache) {\n        // We use the regular localStorage for telemetry due to its large size\n        const cachedTelemetry = localStorage.getItem(cacheKey);\n        if (cachedTelemetry) {\n          try {\n            const parsed = JSON.parse(cachedTelemetry);\n            console.log(`Using cached telemetry data for match: ${matchId}`);\n            return parsed;\n          } catch (e) {\n            // Invalid cache, remove it\n            localStorage.removeItem(cacheKey);\n          }\n        }\n      }\n\n      // Get auth token if available\n      const token = authService.getToken();\n\n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // We need to get the telemetry URL first if not provided\n      if (!telemetryUrl) {\n        console.log(`Fetching match data to get telemetry URL: ${matchId}`);\n        // Try to get from cache first\n        let matchData = null;\n        try {\n          matchData = await this.getMatchDetails(matchId, platform, bypassCache);\n\n          // Extract telemetry URL from match data\n          if (matchData.data && matchData.included) {\n            const assets = matchData.included.filter(item => item.type === 'asset');\n            if (assets.length > 0) {\n              var _assets$, _assets$$attributes;\n              telemetryUrl = (_assets$ = assets[0]) === null || _assets$ === void 0 ? void 0 : (_assets$$attributes = _assets$.attributes) === null || _assets$$attributes === void 0 ? void 0 : _assets$$attributes.URL;\n            }\n          }\n        } catch (error) {\n          console.error('Error getting match data for telemetry:', error);\n        }\n        if (!telemetryUrl) {\n          throw new Error('Could not find telemetry URL for this match');\n        }\n      }\n\n      // Make API request to get telemetry data\n      console.log(`Fetching telemetry data from URL: ${telemetryUrl}`);\n\n      // Telemetry can be very large, so we might need to handle that\n      const response = await axios.get(`/api/telemetry/${matchId}?platform=${platform}`, {\n        headers,\n        timeout: 45000 // Extended timeout for telemetry (increased to 45 seconds)\n      });\n\n      // Cache the telemetry data\n      try {\n        localStorage.setItem(cacheKey, JSON.stringify(response.data));\n        console.log(`Cached telemetry data for match: ${matchId}`);\n      } catch (e) {\n        // Local storage might be full - telemetry can be very large\n        console.warn('Could not cache telemetry data - likely too large for localStorage');\n        // Try to clear some space\n        cacheService.clearOldCache();\n      }\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching telemetry:', error);\n\n      // Handle specific error cases\n      if (error.response) {\n        if (error.response.status === 404) {\n          throw new Error('Telemetry data not found');\n        } else if (error.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          var _error$response$data2;\n          throw new Error(`API error: ${((_error$response$data2 = error.response.data) === null || _error$response$data2 === void 0 ? void 0 : _error$response$data2.error) || 'Unknown error'}`);\n        }\n      } else if (error.code === 'ECONNABORTED') {\n        throw new Error('Request timed out. Telemetry data is large and may take time to load.');\n      } else if (error.code === 'ECONNRESET') {\n        throw new Error('Connection reset by server. Please try again later.');\n      } else if (error.request) {\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        throw error;\n      }\n    }\n  },\n  /**\n   * Search for matches based on criteria with improved reliability\n   * @param {Object} criteria - Search criteria\n   * @returns {Promise<Object>} Search results\n   */\n  async searchMatches(criteria) {\n    try {\n      // Get auth token if available\n      const token = authService.getToken();\n\n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // Try the lite endpoint first which is much faster and more reliable\n      let useRegularEndpoint = false;\n      try {\n        console.log('Trying lite endpoint for match search...');\n        const liteResponse = await axios.post('/api/matches-lite/search', criteria, {\n          headers,\n          timeout: 5000 // Short timeout for lite endpoint\n        });\n\n        // If lite endpoint returns data, use it\n        if (liteResponse.data && liteResponse.data.data && liteResponse.data.data.length > 0) {\n          console.log('Successfully retrieved matches from lite endpoint');\n          return liteResponse.data;\n        }\n\n        // If lite endpoint returns no data, fall back to regular endpoint\n        console.log('Lite endpoint returned no matches, trying regular endpoint...');\n        useRegularEndpoint = true;\n      } catch (liteError) {\n        console.warn('Lite endpoint failed, falling back to regular endpoint:', liteError);\n        useRegularEndpoint = true;\n      }\n\n      // Only use regular endpoint if lite failed or returned no results\n      if (useRegularEndpoint) {\n        console.log('Falling back to regular search endpoint');\n        // Add a timeout to prevent hanging requests\n        const response = await axios.post('/api/matches/search', criteria, {\n          headers,\n          timeout: 30000 // 30 second timeout for search\n        });\n\n        // Make sure we return the data in the expected format\n        return response.data;\n      }\n    } catch (error) {\n      console.error('Error in searchMatches:', error);\n      // Handle specific error cases\n      if (error.response) {\n        // Server responded with an error status\n        if (error.response.status === 401) {\n          throw new Error('Authentication required');\n        } else if (error.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          var _error$response$data3;\n          throw new Error(`API error: ${((_error$response$data3 = error.response.data) === null || _error$response$data3 === void 0 ? void 0 : _error$response$data3.error) || error.response.statusText || 'Unknown error'}`);\n        }\n      } else if (error.code === 'ECONNABORTED') {\n        // Request timed out\n        throw new Error('Request timed out. The server might be overloaded.');\n      } else if (error.code === 'ECONNRESET') {\n        // Connection reset by server\n        throw new Error('Connection reset by server. Please try again later.');\n      } else if (error.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw error;\n      }\n    }\n  },\n  /**\n   * Register a match to a tournament\n   * @param {Object} matchData - Match registration data\n   * @returns {Promise<Object>} Registration result\n   */\n  async registerMatch(matchData) {\n    try {\n      // Get auth token (required for this operation)\n      const token = authService.getToken();\n      if (!token) {\n        throw new Error('Authentication required');\n      }\n\n      // Request headers\n      const headers = {\n        Authorization: `Bearer ${token}`\n      };\n\n      // Make API request\n      const response = await axios.post('/api/matches/register', matchData, {\n        headers\n      });\n      return response.data;\n    } catch (error) {\n      // Handle specific error cases\n      if (error.response) {\n        // Server responded with an error status\n        if (error.response.status === 401) {\n          throw new Error('Authentication required');\n        } else if (error.response.status === 404) {\n          throw new Error('Match not found');\n        } else if (error.response.status === 409) {\n          throw new Error('Match is already registered to a tournament');\n        } else if (error.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          var _error$response$data4;\n          throw new Error(`API error: ${((_error$response$data4 = error.response.data) === null || _error$response$data4 === void 0 ? void 0 : _error$response$data4.error) || 'Unknown error'}`);\n        }\n      } else if (error.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw error;\n      }\n    }\n  }\n};\nexport default matchesServiceEnhanced;","map":{"version":3,"names":["axios","authService","cacheService","matchesServiceEnhanced","getMatchDetails","matchId","platform","bypassCache","cachedMatch","getMatch","console","log","token","getToken","headers","Authorization","liteResponse","get","timeout","data","storeMatch","liteError","response","Error","error","status","warn","_error$response$data","code","request","getTelemetry","telemetryUrl","cacheKey","cachedTelemetry","localStorage","getItem","parsed","JSON","parse","e","removeItem","matchData","included","assets","filter","item","type","length","_assets$","_assets$$attributes","attributes","URL","setItem","stringify","clearOldCache","_error$response$data2","searchMatches","criteria","useRegularEndpoint","post","_error$response$data3","statusText","registerMatch","_error$response$data4"],"sources":["C:/Users/emil/OneDrive/Documents/development/apiDevelopment/pubg-tournament-tracker/client/src/services/matchesServiceEnhanced.js"],"sourcesContent":["import axios from 'axios';\nimport authService from './authService';\nimport cacheService from './cacheService';\n\n// Create a service for handling match-related API calls with enhanced error handling\nconst matchesServiceEnhanced = {\n  /**\n   * Get match details by ID with caching support\n   * @param {string} matchId - PUBG match ID\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API even if cached\n   * @returns {Promise<Object>} Match data\n   */\n  async getMatchDetails(matchId, platform = 'steam', bypassCache = false) {\n    try {\n      // First, check if we have this match cached (unless bypass requested)\n      if (!bypassCache) {\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log(`Using cached data for match: ${matchId}`);\n          return cachedMatch;\n        }\n      }\n      \n      // Get auth token if available\n      const token = authService.getToken();\n      \n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // Try the lite endpoint first for speed\n      try {\n        console.log(`Trying lite endpoint for match: ${matchId}`);\n        const liteResponse = await axios.get(`/api/matches-lite/${matchId}?platform=${platform}`, { \n          headers,\n          timeout: 5000 // Short timeout for lite endpoint\n        });\n        \n        if (liteResponse.data && liteResponse.data.data) {\n          console.log(`Successfully retrieved match from lite endpoint: ${matchId}`);\n          // Cache the successful response\n          cacheService.storeMatch(matchId, platform, liteResponse.data);\n          return liteResponse.data;\n        }\n      } catch (liteError) {\n        // If lite endpoint fails, proceed to regular endpoint\n        console.log(`Lite endpoint failed, trying regular endpoint for match: ${matchId}`);\n      }\n\n      // Make regular API request\n      console.log(`Fetching match data from API: ${matchId}`);\n      const response = await axios.get(`/api/matches/${matchId}?platform=${platform}`, { \n        headers,\n        timeout: 15000 // 15 second timeout for regular API\n      });\n      \n      // If response is empty or missing key attributes, throw an error\n      if (!response.data || !response.data.data) {\n        throw new Error('Invalid response format from API');\n      }\n      \n      // Cache the successful response\n      cacheService.storeMatch(matchId, platform, response.data);\n      \n      return response.data;\n    } catch (error) {\n      // Handle specific error cases\n      if (error.response) {\n        // Handle rate limit specifically\n        if (error.response.status === 429) {\n          console.warn('Rate limit reached for PUBG API, checking cache for fallback');\n          \n          // Check if we have any cached data as fallback\n          const cachedMatch = cacheService.getMatch(matchId, platform);\n          if (cachedMatch) {\n            console.log('Using cached data due to rate limiting');\n            return cachedMatch;\n          }\n          \n          throw new Error('API rate limit exceeded and no cached data available. Please try again later.');\n        } \n        else if (error.response.status === 404) {\n          throw new Error('Match not found');\n        } else if (error.response.status === 401) {\n          throw new Error('Authentication required');\n        } else {\n          throw new Error(`API error: ${error.response.data?.error || 'Unknown error'}`);\n        }\n      } else if (error.code === 'ECONNABORTED') {\n        console.warn('Request timeout, checking cache for fallback');\n        // Check cache as fallback\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data due to timeout');\n          return cachedMatch;\n        }\n        throw new Error('Request timed out. The server might be overloaded.');\n      } else if (error.code === 'ECONNRESET') {\n        console.warn('Connection reset by server, checking cache for fallback');\n        // Check cache as fallback\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data due to connection reset');\n          return cachedMatch;\n        }\n        throw new Error('Connection reset by server. Please try again later.');\n      } else if (error.request) {\n        // No response received, check cache as fallback\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data due to connection issue');\n          return cachedMatch;\n        }\n        \n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw error;\n      }\n    }\n  },\n  \n  /**\n   * Get telemetry data for a match with caching\n   * @param {string} matchId - PUBG match ID\n   * @param {string} telemetryUrl - URL to telemetry data (if known)\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API\n   * @returns {Promise<Object>} Telemetry data\n   */\n  async getTelemetry(matchId, telemetryUrl = null, platform = 'steam', bypassCache = false) {\n    const cacheKey = `telemetry_${matchId}`;\n    \n    try {\n      // Check cache first\n      if (!bypassCache) {\n        // We use the regular localStorage for telemetry due to its large size\n        const cachedTelemetry = localStorage.getItem(cacheKey);\n        if (cachedTelemetry) {\n          try {\n            const parsed = JSON.parse(cachedTelemetry);\n            console.log(`Using cached telemetry data for match: ${matchId}`);\n            return parsed;\n          } catch (e) {\n            // Invalid cache, remove it\n            localStorage.removeItem(cacheKey);\n          }\n        }\n      }\n      \n      // Get auth token if available\n      const token = authService.getToken();\n      \n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // We need to get the telemetry URL first if not provided\n      if (!telemetryUrl) {\n        console.log(`Fetching match data to get telemetry URL: ${matchId}`);\n        // Try to get from cache first\n        let matchData = null;\n        \n        try {\n          matchData = await this.getMatchDetails(matchId, platform, bypassCache);\n          \n          // Extract telemetry URL from match data\n          if (matchData.data && matchData.included) {\n            const assets = matchData.included.filter(item => item.type === 'asset');\n            if (assets.length > 0) {\n              telemetryUrl = assets[0]?.attributes?.URL;\n            }\n          }\n        } catch (error) {\n          console.error('Error getting match data for telemetry:', error);\n        }\n        \n        if (!telemetryUrl) {\n          throw new Error('Could not find telemetry URL for this match');\n        }\n      }\n\n      // Make API request to get telemetry data\n      console.log(`Fetching telemetry data from URL: ${telemetryUrl}`);\n      \n      // Telemetry can be very large, so we might need to handle that\n      const response = await axios.get(`/api/telemetry/${matchId}?platform=${platform}`, { \n        headers,\n        timeout: 45000 // Extended timeout for telemetry (increased to 45 seconds)\n      });\n      \n      // Cache the telemetry data\n      try {\n        localStorage.setItem(cacheKey, JSON.stringify(response.data));\n        console.log(`Cached telemetry data for match: ${matchId}`);\n      } catch (e) {\n        // Local storage might be full - telemetry can be very large\n        console.warn('Could not cache telemetry data - likely too large for localStorage');\n        // Try to clear some space\n        cacheService.clearOldCache();\n      }\n      \n      return response.data;\n    } catch (error) {\n      console.error('Error fetching telemetry:', error);\n      \n      // Handle specific error cases\n      if (error.response) {\n        if (error.response.status === 404) {\n          throw new Error('Telemetry data not found');\n        } else if (error.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          throw new Error(`API error: ${error.response.data?.error || 'Unknown error'}`);\n        }\n      } else if (error.code === 'ECONNABORTED') {\n        throw new Error('Request timed out. Telemetry data is large and may take time to load.');\n      } else if (error.code === 'ECONNRESET') {\n        throw new Error('Connection reset by server. Please try again later.');\n      } else if (error.request) {\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        throw error;\n      }\n    }\n  },\n  \n  /**\n   * Search for matches based on criteria with improved reliability\n   * @param {Object} criteria - Search criteria\n   * @returns {Promise<Object>} Search results\n   */\n  async searchMatches(criteria) {\n    try {\n      // Get auth token if available\n      const token = authService.getToken();\n      \n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // Try the lite endpoint first which is much faster and more reliable\n      let useRegularEndpoint = false;\n      \n      try {\n        console.log('Trying lite endpoint for match search...');\n        const liteResponse = await axios.post('/api/matches-lite/search', criteria, { \n          headers,\n          timeout: 5000 // Short timeout for lite endpoint\n        });\n        \n        // If lite endpoint returns data, use it\n        if (liteResponse.data && liteResponse.data.data && liteResponse.data.data.length > 0) {\n          console.log('Successfully retrieved matches from lite endpoint');\n          return liteResponse.data;\n        }\n        \n        // If lite endpoint returns no data, fall back to regular endpoint\n        console.log('Lite endpoint returned no matches, trying regular endpoint...');\n        useRegularEndpoint = true;\n      } catch (liteError) {\n        console.warn('Lite endpoint failed, falling back to regular endpoint:', liteError);\n        useRegularEndpoint = true;\n      }\n      \n      // Only use regular endpoint if lite failed or returned no results\n      if (useRegularEndpoint) {\n        console.log('Falling back to regular search endpoint');\n        // Add a timeout to prevent hanging requests\n        const response = await axios.post('/api/matches/search', criteria, { \n          headers,\n          timeout: 30000 // 30 second timeout for search\n        });\n        \n        // Make sure we return the data in the expected format\n        return response.data;\n      }\n    } catch (error) {\n      console.error('Error in searchMatches:', error);\n      // Handle specific error cases\n      if (error.response) {\n        // Server responded with an error status\n        if (error.response.status === 401) {\n          throw new Error('Authentication required');\n        } else if (error.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          throw new Error(`API error: ${error.response.data?.error || error.response.statusText || 'Unknown error'}`);\n        }\n      } else if (error.code === 'ECONNABORTED') {\n        // Request timed out\n        throw new Error('Request timed out. The server might be overloaded.');\n      } else if (error.code === 'ECONNRESET') {\n        // Connection reset by server\n        throw new Error('Connection reset by server. Please try again later.');\n      } else if (error.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw error;\n      }\n    }\n  },\n  \n  /**\n   * Register a match to a tournament\n   * @param {Object} matchData - Match registration data\n   * @returns {Promise<Object>} Registration result\n   */\n  async registerMatch(matchData) {\n    try {\n      // Get auth token (required for this operation)\n      const token = authService.getToken();\n      if (!token) {\n        throw new Error('Authentication required');\n      }\n      \n      // Request headers\n      const headers = {\n        Authorization: `Bearer ${token}`\n      };\n\n      // Make API request\n      const response = await axios.post('/api/matches/register', matchData, { headers });\n      \n      return response.data;\n    } catch (error) {\n      // Handle specific error cases\n      if (error.response) {\n        // Server responded with an error status\n        if (error.response.status === 401) {\n          throw new Error('Authentication required');\n        } else if (error.response.status === 404) {\n          throw new Error('Match not found');\n        } else if (error.response.status === 409) {\n          throw new Error('Match is already registered to a tournament');\n        } else if (error.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          throw new Error(`API error: ${error.response.data?.error || 'Unknown error'}`);\n        }\n      } else if (error.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw error;\n      }\n    }\n  }\n};\n\nexport default matchesServiceEnhanced;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}