{"ast":null,"code":"// cacheService.js - Local storage based caching for PUBG match data\nconst CACHE_PREFIX = 'pubg_match_';\nconst CACHE_EXPIRY = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\n\nexport const cacheService = {\n  /**\n   * Store match data in localStorage\n   * @param {string} matchId - PUBG match ID\n   * @param {string} platform - Platform (steam, xbox, etc.)\n   * @param {Object} data - Match data to cache\n   * @returns {boolean} Success status\n   */\n  storeMatch(matchId, platform, data) {\n    try {\n      const cacheKey = `${CACHE_PREFIX}${platform}_${matchId}`;\n      const cacheData = {\n        data: data,\n        timestamp: Date.now(),\n        expires: Date.now() + CACHE_EXPIRY\n      };\n      localStorage.setItem(cacheKey, JSON.stringify(cacheData));\n      console.log(`Cached match data for: ${matchId}`);\n      return true;\n    } catch (error) {\n      console.error('Error storing match in cache:', error);\n      // If localStorage is full, try to clear older items\n      if (error instanceof DOMException && error.name === 'QuotaExceededError') {\n        this.clearOldCache();\n      }\n      return false;\n    }\n  },\n  /**\n   * Get match data from localStorage if available and not expired\n   * @param {string} matchId - PUBG match ID\n   * @param {string} platform - Platform (steam, xbox, etc.)\n   * @returns {Object|null} Cached match data or null\n   */\n  getMatch(matchId, platform) {\n    try {\n      const cacheKey = `${CACHE_PREFIX}${platform}_${matchId}`;\n      const cachedData = localStorage.getItem(cacheKey);\n      if (!cachedData) return null;\n      const parsed = JSON.parse(cachedData);\n\n      // Check if cache is expired (technically unnecessary for match data since it's immutable,\n      // but good practice for cache management)\n      if (parsed.expires < Date.now()) {\n        localStorage.removeItem(cacheKey);\n        return null;\n      }\n      return parsed.data;\n    } catch (error) {\n      console.error('Error retrieving match from cache:', error);\n      return null;\n    }\n  },\n  /**\n   * Clear expired or old cache entries\n   */\n  clearOldCache() {\n    try {\n      // Get all keys in localStorage that match our cache prefix\n      const keys = [];\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && key.startsWith(CACHE_PREFIX)) {\n          keys.push(key);\n        }\n      }\n\n      // Find expired or old items\n      const now = Date.now();\n      const itemsToRemove = [];\n      keys.forEach(key => {\n        try {\n          const value = localStorage.getItem(key);\n          if (value) {\n            const parsed = JSON.parse(value);\n            // Remove if expired or older than half the expiry time\n            if (parsed.expires < now || now - parsed.timestamp > CACHE_EXPIRY / 2) {\n              itemsToRemove.push(key);\n            }\n          } else {\n            // Invalid item\n            itemsToRemove.push(key);\n          }\n        } catch (e) {\n          // If we can't parse it, it's corrupted\n          itemsToRemove.push(key);\n        }\n      });\n\n      // Remove old/expired items\n      itemsToRemove.forEach(key => {\n        localStorage.removeItem(key);\n      });\n      console.log(`Cleared ${itemsToRemove.length} old cache entries`);\n    } catch (error) {\n      console.error('Error clearing old cache:', error);\n    }\n  }\n};\nexport default cacheService;","map":{"version":3,"names":["CACHE_PREFIX","CACHE_EXPIRY","cacheService","storeMatch","matchId","platform","data","cacheKey","cacheData","timestamp","Date","now","expires","localStorage","setItem","JSON","stringify","console","log","error","DOMException","name","clearOldCache","getMatch","cachedData","getItem","parsed","parse","removeItem","keys","i","length","key","startsWith","push","itemsToRemove","forEach","value","e"],"sources":["C:/Users/emil/OneDrive/Documents/development/apiDevelopment/pubg-tournament-tracker/client/src/services/cacheService.js"],"sourcesContent":["// cacheService.js - Local storage based caching for PUBG match data\nconst CACHE_PREFIX = 'pubg_match_';\nconst CACHE_EXPIRY = 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds\n\nexport const cacheService = {\n  /**\n   * Store match data in localStorage\n   * @param {string} matchId - PUBG match ID\n   * @param {string} platform - Platform (steam, xbox, etc.)\n   * @param {Object} data - Match data to cache\n   * @returns {boolean} Success status\n   */\n  storeMatch(matchId, platform, data) {\n    try {\n      const cacheKey = `${CACHE_PREFIX}${platform}_${matchId}`;\n      const cacheData = {\n        data: data,\n        timestamp: Date.now(),\n        expires: Date.now() + CACHE_EXPIRY\n      };\n      localStorage.setItem(cacheKey, JSON.stringify(cacheData));\n      console.log(`Cached match data for: ${matchId}`);\n      return true;\n    } catch (error) {\n      console.error('Error storing match in cache:', error);\n      // If localStorage is full, try to clear older items\n      if (error instanceof DOMException && error.name === 'QuotaExceededError') {\n        this.clearOldCache();\n      }\n      return false;\n    }\n  },\n\n  /**\n   * Get match data from localStorage if available and not expired\n   * @param {string} matchId - PUBG match ID\n   * @param {string} platform - Platform (steam, xbox, etc.)\n   * @returns {Object|null} Cached match data or null\n   */\n  getMatch(matchId, platform) {\n    try {\n      const cacheKey = `${CACHE_PREFIX}${platform}_${matchId}`;\n      const cachedData = localStorage.getItem(cacheKey);\n      \n      if (!cachedData) return null;\n      \n      const parsed = JSON.parse(cachedData);\n      \n      // Check if cache is expired (technically unnecessary for match data since it's immutable,\n      // but good practice for cache management)\n      if (parsed.expires < Date.now()) {\n        localStorage.removeItem(cacheKey);\n        return null;\n      }\n      \n      return parsed.data;\n    } catch (error) {\n      console.error('Error retrieving match from cache:', error);\n      return null;\n    }\n  },\n  \n  /**\n   * Clear expired or old cache entries\n   */\n  clearOldCache() {\n    try {\n      // Get all keys in localStorage that match our cache prefix\n      const keys = [];\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && key.startsWith(CACHE_PREFIX)) {\n          keys.push(key);\n        }\n      }\n      \n      // Find expired or old items\n      const now = Date.now();\n      const itemsToRemove = [];\n      \n      keys.forEach(key => {\n        try {\n          const value = localStorage.getItem(key);\n          if (value) {\n            const parsed = JSON.parse(value);\n            // Remove if expired or older than half the expiry time\n            if (parsed.expires < now || (now - parsed.timestamp) > (CACHE_EXPIRY / 2)) {\n              itemsToRemove.push(key);\n            }\n          } else {\n            // Invalid item\n            itemsToRemove.push(key);\n          }\n        } catch (e) {\n          // If we can't parse it, it's corrupted\n          itemsToRemove.push(key);\n        }\n      });\n      \n      // Remove old/expired items\n      itemsToRemove.forEach(key => {\n        localStorage.removeItem(key);\n      });\n      \n      console.log(`Cleared ${itemsToRemove.length} old cache entries`);\n    } catch (error) {\n      console.error('Error clearing old cache:', error);\n    }\n  }\n};\n\nexport default cacheService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}