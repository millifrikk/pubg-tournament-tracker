{"ast":null,"code":"import axios from 'axios';\nimport authService from './authService';\nimport cacheService from './cacheService';\n\n// Create a service for handling match-related API calls\nconst matchesService = {\n  /**\n   * Get match details by ID with caching support\n   * @param {string} matchId - PUBG match ID\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API even if cached\n   * @returns {Promise<Object>} Match data\n   */\n  async getMatchDetails(matchId, platform = 'steam', bypassCache = false) {\n    try {\n      // First, check if we have this match cached (unless bypass requested)\n      if (!bypassCache) {\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log(`Using cached data for match: ${matchId}`);\n          return cachedMatch;\n        }\n      }\n\n      // Get auth token if available\n      const token = authService.getToken();\n\n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // Make API request\n      console.log(`Fetching match data from API: ${matchId}`);\n      const response = await axios.get(`/api/matches/${matchId}?platform=${platform}`, {\n        headers\n      });\n\n      // If response is empty or missing key attributes, throw an error\n      if (!response.data || !response.data.data) {\n        throw new Error('Invalid response format from API');\n      }\n\n      // Cache the successful response\n      cacheService.storeMatch(matchId, platform, response.data);\n      return response.data;\n    } catch (error) {\n      // Handle specific error cases\n      if (error.response) {\n        // Handle rate limit specifically\n        if (error.response.status === 429) {\n          console.warn('Rate limit reached for PUBG API, checking cache for fallback');\n\n          // Check if we have any cached data as fallback\n          const cachedMatch = cacheService.getMatch(matchId, platform);\n          if (cachedMatch) {\n            console.log('Using cached data due to rate limiting');\n            return cachedMatch;\n          }\n          throw new Error('API rate limit exceeded and no cached data available. Please try again later.');\n        } else if (error.response.status === 404) {\n          throw new Error('Match not found');\n        } else if (error.response.status === 401) {\n          throw new Error('Authentication required');\n        } else {\n          var _error$response$data;\n          throw new Error(`API error: ${((_error$response$data = error.response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.error) || 'Unknown error'}`);\n        }\n      } else if (error.request) {\n        // No response received, check cache as fallback\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data due to connection issue');\n          return cachedMatch;\n        }\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw error;\n      }\n    }\n  },\n  /**\n   * Get telemetry data for a match with caching\n   * @param {string} matchId - PUBG match ID\n   * @param {string} telemetryUrl - URL to telemetry data (if known)\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API\n   * @returns {Promise<Object>} Telemetry data\n   */\n  async getTelemetry(matchId, telemetryUrl = null, platform = 'steam', bypassCache = false) {\n    const cacheKey = `telemetry_${matchId}`;\n    try {\n      // Check cache first\n      if (!bypassCache) {\n        // We use the regular localStorage for telemetry due to its large size\n        const cachedTelemetry = localStorage.getItem(cacheKey);\n        if (cachedTelemetry) {\n          try {\n            const parsed = JSON.parse(cachedTelemetry);\n            console.log(`Using cached telemetry data for match: ${matchId}`);\n            return parsed;\n          } catch (e) {\n            // Invalid cache, remove it\n            localStorage.removeItem(cacheKey);\n          }\n        }\n      }\n\n      // Get auth token if available\n      const token = authService.getToken();\n\n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // We need to get the telemetry URL first if not provided\n      if (!telemetryUrl) {\n        console.log(`Fetching match data to get telemetry URL: ${matchId}`);\n        // Try to get from cache first\n        let matchData = null;\n        try {\n          matchData = await this.getMatchDetails(matchId, platform, bypassCache);\n\n          // Extract telemetry URL from match data\n          if (matchData.data && matchData.included) {\n            const assets = matchData.included.filter(item => item.type === 'asset');\n            if (assets.length > 0) {\n              var _assets$, _assets$$attributes;\n              telemetryUrl = (_assets$ = assets[0]) === null || _assets$ === void 0 ? void 0 : (_assets$$attributes = _assets$.attributes) === null || _assets$$attributes === void 0 ? void 0 : _assets$$attributes.URL;\n            }\n          }\n        } catch (error) {\n          console.error('Error getting match data for telemetry:', error);\n        }\n        if (!telemetryUrl) {\n          throw new Error('Could not find telemetry URL for this match');\n        }\n      }\n\n      // Make API request to get telemetry data\n      console.log(`Fetching telemetry data from URL: ${telemetryUrl}`);\n\n      // Telemetry can be very large, so we might need to handle that\n      const response = await axios.get(telemetryUrl, {\n        headers,\n        timeout: 30000 // Extended timeout for large telemetry files\n      });\n\n      // Cache the telemetry data\n      try {\n        localStorage.setItem(cacheKey, JSON.stringify(response.data));\n        console.log(`Cached telemetry data for match: ${matchId}`);\n      } catch (e) {\n        // Local storage might be full - telemetry can be very large\n        console.warn('Could not cache telemetry data - likely too large for localStorage');\n        // Try to clear some space\n        cacheService.clearOldCache();\n      }\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching telemetry:', error);\n\n      // Handle specific error cases\n      if (error.response) {\n        if (error.response.status === 404) {\n          throw new Error('Telemetry data not found');\n        } else if (error.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          var _error$response$data2;\n          throw new Error(`API error: ${((_error$response$data2 = error.response.data) === null || _error$response$data2 === void 0 ? void 0 : _error$response$data2.error) || 'Unknown error'}`);\n        }\n      } else if (error.request) {\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        throw error;\n      }\n    }\n  },\n  /**\n   * Search for matches based on criteria\n   * @param {Object} criteria - Search criteria\n   * @returns {Promise<Object>} Search results\n   */\n  async searchMatches(criteria) {\n    try {\n      // Get auth token if available\n      const token = authService.getToken();\n\n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // Make API request\n      const response = await axios.post('/api/matches/search', criteria, {\n        headers\n      });\n      return response.data;\n    } catch (error) {\n      // Handle specific error cases\n      if (error.response) {\n        // Server responded with an error status\n        if (error.response.status === 401) {\n          throw new Error('Authentication required');\n        } else if (error.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          var _error$response$data3;\n          throw new Error(`API error: ${((_error$response$data3 = error.response.data) === null || _error$response$data3 === void 0 ? void 0 : _error$response$data3.error) || 'Unknown error'}`);\n        }\n      } else if (error.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw error;\n      }\n    }\n  },\n  /**\n   * Register a match to a tournament\n   * @param {Object} matchData - Match registration data\n   * @returns {Promise<Object>} Registration result\n   */\n  async registerMatch(matchData) {\n    try {\n      // Get auth token (required for this operation)\n      const token = authService.getToken();\n      if (!token) {\n        throw new Error('Authentication required');\n      }\n\n      // Request headers\n      const headers = {\n        Authorization: `Bearer ${token}`\n      };\n\n      // Make API request\n      const response = await axios.post('/api/matches/register', matchData, {\n        headers\n      });\n      return response.data;\n    } catch (error) {\n      // Handle specific error cases\n      if (error.response) {\n        // Server responded with an error status\n        if (error.response.status === 401) {\n          throw new Error('Authentication required');\n        } else if (error.response.status === 404) {\n          throw new Error('Match not found');\n        } else if (error.response.status === 409) {\n          throw new Error('Match is already registered to a tournament');\n        } else if (error.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          var _error$response$data4;\n          throw new Error(`API error: ${((_error$response$data4 = error.response.data) === null || _error$response$data4 === void 0 ? void 0 : _error$response$data4.error) || 'Unknown error'}`);\n        }\n      } else if (error.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw error;\n      }\n    }\n  }\n};\nexport default matchesService;","map":{"version":3,"names":["axios","authService","cacheService","matchesService","getMatchDetails","matchId","platform","bypassCache","cachedMatch","getMatch","console","log","token","getToken","headers","Authorization","response","get","data","Error","storeMatch","error","status","warn","_error$response$data","request","getTelemetry","telemetryUrl","cacheKey","cachedTelemetry","localStorage","getItem","parsed","JSON","parse","e","removeItem","matchData","included","assets","filter","item","type","length","_assets$","_assets$$attributes","attributes","URL","timeout","setItem","stringify","clearOldCache","_error$response$data2","searchMatches","criteria","post","_error$response$data3","registerMatch","_error$response$data4"],"sources":["C:/Users/emil/OneDrive/Documents/development/apiDevelopment/pubg-tournament-tracker/client/src/services/matchesService.js"],"sourcesContent":["import axios from 'axios';\nimport authService from './authService';\nimport cacheService from './cacheService';\n\n// Create a service for handling match-related API calls\nconst matchesService = {\n  /**\n   * Get match details by ID with caching support\n   * @param {string} matchId - PUBG match ID\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API even if cached\n   * @returns {Promise<Object>} Match data\n   */\n  async getMatchDetails(matchId, platform = 'steam', bypassCache = false) {\n    try {\n      // First, check if we have this match cached (unless bypass requested)\n      if (!bypassCache) {\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log(`Using cached data for match: ${matchId}`);\n          return cachedMatch;\n        }\n      }\n      \n      // Get auth token if available\n      const token = authService.getToken();\n      \n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // Make API request\n      console.log(`Fetching match data from API: ${matchId}`);\n      const response = await axios.get(`/api/matches/${matchId}?platform=${platform}`, { headers });\n      \n      // If response is empty or missing key attributes, throw an error\n      if (!response.data || !response.data.data) {\n        throw new Error('Invalid response format from API');\n      }\n      \n      // Cache the successful response\n      cacheService.storeMatch(matchId, platform, response.data);\n      \n      return response.data;\n    } catch (error) {\n      // Handle specific error cases\n      if (error.response) {\n        // Handle rate limit specifically\n        if (error.response.status === 429) {\n          console.warn('Rate limit reached for PUBG API, checking cache for fallback');\n          \n          // Check if we have any cached data as fallback\n          const cachedMatch = cacheService.getMatch(matchId, platform);\n          if (cachedMatch) {\n            console.log('Using cached data due to rate limiting');\n            return cachedMatch;\n          }\n          \n          throw new Error('API rate limit exceeded and no cached data available. Please try again later.');\n        } \n        else if (error.response.status === 404) {\n          throw new Error('Match not found');\n        } else if (error.response.status === 401) {\n          throw new Error('Authentication required');\n        } else {\n          throw new Error(`API error: ${error.response.data?.error || 'Unknown error'}`);\n        }\n      } else if (error.request) {\n        // No response received, check cache as fallback\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data due to connection issue');\n          return cachedMatch;\n        }\n        \n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw error;\n      }\n    }\n  },\n  \n  /**\n   * Get telemetry data for a match with caching\n   * @param {string} matchId - PUBG match ID\n   * @param {string} telemetryUrl - URL to telemetry data (if known)\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API\n   * @returns {Promise<Object>} Telemetry data\n   */\n  async getTelemetry(matchId, telemetryUrl = null, platform = 'steam', bypassCache = false) {\n    const cacheKey = `telemetry_${matchId}`;\n    \n    try {\n      // Check cache first\n      if (!bypassCache) {\n        // We use the regular localStorage for telemetry due to its large size\n        const cachedTelemetry = localStorage.getItem(cacheKey);\n        if (cachedTelemetry) {\n          try {\n            const parsed = JSON.parse(cachedTelemetry);\n            console.log(`Using cached telemetry data for match: ${matchId}`);\n            return parsed;\n          } catch (e) {\n            // Invalid cache, remove it\n            localStorage.removeItem(cacheKey);\n          }\n        }\n      }\n      \n      // Get auth token if available\n      const token = authService.getToken();\n      \n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // We need to get the telemetry URL first if not provided\n      if (!telemetryUrl) {\n        console.log(`Fetching match data to get telemetry URL: ${matchId}`);\n        // Try to get from cache first\n        let matchData = null;\n        \n        try {\n          matchData = await this.getMatchDetails(matchId, platform, bypassCache);\n          \n          // Extract telemetry URL from match data\n          if (matchData.data && matchData.included) {\n            const assets = matchData.included.filter(item => item.type === 'asset');\n            if (assets.length > 0) {\n              telemetryUrl = assets[0]?.attributes?.URL;\n            }\n          }\n        } catch (error) {\n          console.error('Error getting match data for telemetry:', error);\n        }\n        \n        if (!telemetryUrl) {\n          throw new Error('Could not find telemetry URL for this match');\n        }\n      }\n\n      // Make API request to get telemetry data\n      console.log(`Fetching telemetry data from URL: ${telemetryUrl}`);\n      \n      // Telemetry can be very large, so we might need to handle that\n      const response = await axios.get(telemetryUrl, { \n        headers,\n        timeout: 30000 // Extended timeout for large telemetry files\n      });\n      \n      // Cache the telemetry data\n      try {\n        localStorage.setItem(cacheKey, JSON.stringify(response.data));\n        console.log(`Cached telemetry data for match: ${matchId}`);\n      } catch (e) {\n        // Local storage might be full - telemetry can be very large\n        console.warn('Could not cache telemetry data - likely too large for localStorage');\n        // Try to clear some space\n        cacheService.clearOldCache();\n      }\n      \n      return response.data;\n    } catch (error) {\n      console.error('Error fetching telemetry:', error);\n      \n      // Handle specific error cases\n      if (error.response) {\n        if (error.response.status === 404) {\n          throw new Error('Telemetry data not found');\n        } else if (error.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          throw new Error(`API error: ${error.response.data?.error || 'Unknown error'}`);\n        }\n      } else if (error.request) {\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        throw error;\n      }\n    }\n  },\n  \n  /**\n   * Search for matches based on criteria\n   * @param {Object} criteria - Search criteria\n   * @returns {Promise<Object>} Search results\n   */\n  async searchMatches(criteria) {\n    try {\n      // Get auth token if available\n      const token = authService.getToken();\n      \n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // Make API request\n      const response = await axios.post('/api/matches/search', criteria, { headers });\n      \n      return response.data;\n    } catch (error) {\n      // Handle specific error cases\n      if (error.response) {\n        // Server responded with an error status\n        if (error.response.status === 401) {\n          throw new Error('Authentication required');\n        } else if (error.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          throw new Error(`API error: ${error.response.data?.error || 'Unknown error'}`);\n        }\n      } else if (error.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw error;\n      }\n    }\n  },\n  \n  /**\n   * Register a match to a tournament\n   * @param {Object} matchData - Match registration data\n   * @returns {Promise<Object>} Registration result\n   */\n  async registerMatch(matchData) {\n    try {\n      // Get auth token (required for this operation)\n      const token = authService.getToken();\n      if (!token) {\n        throw new Error('Authentication required');\n      }\n      \n      // Request headers\n      const headers = {\n        Authorization: `Bearer ${token}`\n      };\n\n      // Make API request\n      const response = await axios.post('/api/matches/register', matchData, { headers });\n      \n      return response.data;\n    } catch (error) {\n      // Handle specific error cases\n      if (error.response) {\n        // Server responded with an error status\n        if (error.response.status === 401) {\n          throw new Error('Authentication required');\n        } else if (error.response.status === 404) {\n          throw new Error('Match not found');\n        } else if (error.response.status === 409) {\n          throw new Error('Match is already registered to a tournament');\n        } else if (error.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          throw new Error(`API error: ${error.response.data?.error || 'Unknown error'}`);\n        }\n      } else if (error.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw error;\n      }\n    }\n  }\n};\n\nexport default matchesService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}