{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\emil\\\\OneDrive\\\\Documents\\\\development\\\\apiDevelopment\\\\pubg-tournament-tracker\\\\client\\\\src\\\\contexts\\\\SocketContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect, useRef } from 'react';\nimport io from 'socket.io-client';\n\n// Create the socket context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SocketContext = /*#__PURE__*/createContext();\n\n// Socket provider component\nexport const SocketProvider = ({\n  children\n}) => {\n  _s();\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [joinedMatches, setJoinedMatches] = useState([]);\n\n  // Use a ref to keep track of active matches without causing re-renders\n  const joinedMatchesRef = useRef([]);\n\n  // Create socket as a ref to avoid recreation\n  const socketRef = useRef(null);\n\n  // Initialize socket connection once\n  useEffect(() => {\n    // Get base URL from environment or use default\n    const baseUrl = process.env.REACT_APP_SOCKET_URL || window.location.origin;\n\n    // Create socket instance only if it doesn't exist\n    if (!socketRef.current) {\n      console.log('Creating new socket connection');\n      socketRef.current = io(baseUrl, {\n        autoConnect: true,\n        reconnection: true,\n        reconnectionAttempts: 5,\n        reconnectionDelay: 1000,\n        timeout: 10000\n      });\n\n      // Socket event handlers\n      socketRef.current.on('connect', () => {\n        console.log('Socket connected');\n        setIsConnected(true);\n\n        // Rejoin any previously joined match rooms after a small delay\n        // Using the ref instead of state to avoid render loops\n        setTimeout(() => {\n          if (joinedMatchesRef.current.length > 0) {\n            console.log(`Rejoining ${joinedMatchesRef.current.length} match rooms`);\n            joinedMatchesRef.current.forEach(matchId => {\n              socketRef.current.emit('join-match', {\n                matchId\n              });\n            });\n          }\n        }, 300);\n      });\n      socketRef.current.on('disconnect', () => {\n        console.log('Socket disconnected');\n        setIsConnected(false);\n      });\n      socketRef.current.on('connect_error', error => {\n        console.error('Socket connection error:', error);\n      });\n\n      // Save socket instance to state for components to use\n      setSocket(socketRef.current);\n    }\n\n    // Cleanup on unmount\n    return () => {\n      // We don't disconnect on unmount because other components might still need it\n      // Instead we just log that we're leaving the component\n      console.log('SocketProvider unmounting');\n    };\n  }, []); // Empty dependency array - this effect runs exactly once\n\n  // Join a match room to receive updates\n  const joinMatch = matchId => {\n    if (!matchId) return;\n    console.log(`Joining match room: ${matchId}`);\n    if (socketRef.current) {\n      socketRef.current.emit('join-match', {\n        matchId\n      });\n    }\n\n    // Track joined matches in both state and ref\n    // The ref is used for reconnection logic to avoid render loops\n    if (!joinedMatchesRef.current.includes(matchId)) {\n      joinedMatchesRef.current.push(matchId);\n\n      // Also update state for component usage but throttle it\n      // This won't cause rapid re-renders in components using this context\n      setJoinedMatches(prevMatches => {\n        if (!prevMatches.includes(matchId)) {\n          return [...prevMatches, matchId];\n        }\n        return prevMatches;\n      });\n    }\n  };\n\n  // Leave a match room\n  const leaveMatch = matchId => {\n    if (!matchId) return;\n    console.log(`Leaving match room: ${matchId}`);\n    if (socketRef.current) {\n      socketRef.current.emit('leave-match', {\n        matchId\n      });\n    }\n\n    // Update both the ref and the state\n    joinedMatchesRef.current = joinedMatchesRef.current.filter(id => id !== matchId);\n    setJoinedMatches(prevMatches => prevMatches.filter(id => id !== matchId));\n  };\n\n  // Socket context value - memoize to avoid unnecessary re-renders\n  const contextValue = React.useMemo(() => ({\n    socket,\n    isConnected,\n    joinMatch,\n    leaveMatch,\n    // Event subscription helpers\n    subscribeToEvent: (event, callback) => {\n      if (socketRef.current) {\n        socketRef.current.on(event, callback);\n        return () => {\n          var _socketRef$current;\n          return (_socketRef$current = socketRef.current) === null || _socketRef$current === void 0 ? void 0 : _socketRef$current.off(event, callback);\n        };\n      }\n      return () => {};\n    },\n    emitEvent: (event, data) => {\n      if (socketRef.current) {\n        socketRef.current.emit(event, data);\n      }\n    }\n  }), [socket, isConnected]); // Only depend on these two state variables\n\n  return /*#__PURE__*/_jsxDEV(SocketContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 136,\n    columnNumber: 5\n  }, this);\n};\n\n// Custom hook to use the socket context\n_s(SocketProvider, \"d4ddLhcn5WWNwHvGx1PkjYY332E=\");\n_c = SocketProvider;\nexport const useSocket = () => {\n  _s2();\n  const context = useContext(SocketContext);\n  if (!context) {\n    console.warn('useSocket must be used within a SocketProvider');\n    // Return mock implementation to prevent errors\n    return {\n      socket: null,\n      isConnected: false,\n      joinMatch: () => {},\n      leaveMatch: () => {},\n      subscribeToEvent: () => () => {},\n      emitEvent: () => {}\n    };\n  }\n  return context;\n};\n_s2(useSocket, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"SocketProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useRef","io","jsxDEV","_jsxDEV","SocketContext","SocketProvider","children","_s","socket","setSocket","isConnected","setIsConnected","joinedMatches","setJoinedMatches","joinedMatchesRef","socketRef","baseUrl","process","env","REACT_APP_SOCKET_URL","window","location","origin","current","console","log","autoConnect","reconnection","reconnectionAttempts","reconnectionDelay","timeout","on","setTimeout","length","forEach","matchId","emit","error","joinMatch","includes","push","prevMatches","leaveMatch","filter","id","contextValue","useMemo","subscribeToEvent","event","callback","_socketRef$current","off","emitEvent","data","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useSocket","_s2","context","warn","$RefreshReg$"],"sources":["C:/Users/emil/OneDrive/Documents/development/apiDevelopment/pubg-tournament-tracker/client/src/contexts/SocketContext.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useRef } from 'react';\nimport io from 'socket.io-client';\n\n// Create the socket context\nconst SocketContext = createContext();\n\n// Socket provider component\nexport const SocketProvider = ({ children }) => {\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [joinedMatches, setJoinedMatches] = useState([]);\n\n  // Use a ref to keep track of active matches without causing re-renders\n  const joinedMatchesRef = useRef([]);\n  \n  // Create socket as a ref to avoid recreation\n  const socketRef = useRef(null);\n\n  // Initialize socket connection once\n  useEffect(() => {\n    // Get base URL from environment or use default\n    const baseUrl = process.env.REACT_APP_SOCKET_URL || window.location.origin;\n    \n    // Create socket instance only if it doesn't exist\n    if (!socketRef.current) {\n      console.log('Creating new socket connection');\n      socketRef.current = io(baseUrl, {\n        autoConnect: true,\n        reconnection: true,\n        reconnectionAttempts: 5,\n        reconnectionDelay: 1000,\n        timeout: 10000\n      });\n\n      // Socket event handlers\n      socketRef.current.on('connect', () => {\n        console.log('Socket connected');\n        setIsConnected(true);\n        \n        // Rejoin any previously joined match rooms after a small delay\n        // Using the ref instead of state to avoid render loops\n        setTimeout(() => {\n          if (joinedMatchesRef.current.length > 0) {\n            console.log(`Rejoining ${joinedMatchesRef.current.length} match rooms`);\n            joinedMatchesRef.current.forEach(matchId => {\n              socketRef.current.emit('join-match', { matchId });\n            });\n          }\n        }, 300);\n      });\n\n      socketRef.current.on('disconnect', () => {\n        console.log('Socket disconnected');\n        setIsConnected(false);\n      });\n\n      socketRef.current.on('connect_error', (error) => {\n        console.error('Socket connection error:', error);\n      });\n\n      // Save socket instance to state for components to use\n      setSocket(socketRef.current);\n    }\n\n    // Cleanup on unmount\n    return () => {\n      // We don't disconnect on unmount because other components might still need it\n      // Instead we just log that we're leaving the component\n      console.log('SocketProvider unmounting');\n    };\n  }, []); // Empty dependency array - this effect runs exactly once\n\n  // Join a match room to receive updates\n  const joinMatch = (matchId) => {\n    if (!matchId) return;\n    \n    console.log(`Joining match room: ${matchId}`);\n    \n    if (socketRef.current) {\n      socketRef.current.emit('join-match', { matchId });\n    }\n    \n    // Track joined matches in both state and ref\n    // The ref is used for reconnection logic to avoid render loops\n    if (!joinedMatchesRef.current.includes(matchId)) {\n      joinedMatchesRef.current.push(matchId);\n      \n      // Also update state for component usage but throttle it\n      // This won't cause rapid re-renders in components using this context\n      setJoinedMatches(prevMatches => {\n        if (!prevMatches.includes(matchId)) {\n          return [...prevMatches, matchId];\n        }\n        return prevMatches;\n      });\n    }\n  };\n\n  // Leave a match room\n  const leaveMatch = (matchId) => {\n    if (!matchId) return;\n    \n    console.log(`Leaving match room: ${matchId}`);\n    \n    if (socketRef.current) {\n      socketRef.current.emit('leave-match', { matchId });\n    }\n    \n    // Update both the ref and the state\n    joinedMatchesRef.current = joinedMatchesRef.current.filter(id => id !== matchId);\n    setJoinedMatches(prevMatches => prevMatches.filter(id => id !== matchId));\n  };\n\n  // Socket context value - memoize to avoid unnecessary re-renders\n  const contextValue = React.useMemo(() => ({\n    socket,\n    isConnected,\n    joinMatch,\n    leaveMatch,\n    // Event subscription helpers\n    subscribeToEvent: (event, callback) => {\n      if (socketRef.current) {\n        socketRef.current.on(event, callback);\n        return () => socketRef.current?.off(event, callback);\n      }\n      return () => {};\n    },\n    emitEvent: (event, data) => {\n      if (socketRef.current) {\n        socketRef.current.emit(event, data);\n      }\n    }\n  }), [socket, isConnected]); // Only depend on these two state variables\n\n  return (\n    <SocketContext.Provider value={contextValue}>\n      {children}\n    </SocketContext.Provider>\n  );\n};\n\n// Custom hook to use the socket context\nexport const useSocket = () => {\n  const context = useContext(SocketContext);\n  if (!context) {\n    console.warn('useSocket must be used within a SocketProvider');\n    // Return mock implementation to prevent errors\n    return {\n      socket: null,\n      isConnected: false,\n      joinMatch: () => {},\n      leaveMatch: () => {},\n      subscribeToEvent: () => () => {},\n      emitEvent: () => {}\n    };\n  }\n  return context;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}