{"ast":null,"code":"import axios from 'axios';\nimport authService from './authService';\nimport cacheService from './cacheService';\n\n// Create a service for handling match-related API calls with enhanced error handling\nconst matchesServiceEnhanced = {\n  /**\n   * Get match details by ID with caching support and better error handling\n   * @param {string} matchId - PUBG match ID\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API even if cached\n   * @returns {Promise<Object>} Match data\n   */\n  async getMatchDetails(matchId, platform = 'steam', bypassCache = false) {\n    try {\n      // First, check if we have this match cached (unless bypass requested)\n      if (!bypassCache) {\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log(`Using cached data for match: ${matchId}`);\n          return cachedMatch;\n        }\n      }\n\n      // Get auth token if available\n      const token = authService.getToken();\n\n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // Make API request with retry logic\n      console.log(`Fetching match data from API: ${matchId}`);\n      let retries = 2;\n      let lastError = null;\n      while (retries >= 0) {\n        try {\n          const response = await axios.get(`/api/matches/${matchId}?platform=${platform}`, {\n            headers,\n            timeout: 15000 // 15 second timeout\n          });\n\n          // If response is empty or missing key attributes, throw an error\n          if (!response.data || !response.data.data) {\n            throw new Error('Invalid response format from API');\n          }\n\n          // Cache the successful response\n          cacheService.storeMatch(matchId, platform, response.data);\n          return response.data;\n        } catch (error) {\n          lastError = error;\n\n          // If it's a 404, don't retry\n          if (error.response && error.response.status === 404) {\n            throw new Error('Match not found');\n          }\n\n          // Don't retry if we've exhausted retries\n          if (retries <= 0) {\n            break;\n          }\n\n          // Wait before retry (1s, then 2s)\n          const delay = (2 - retries) * 1000 + 1000;\n          console.log(`Retrying after ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n          retries--;\n        }\n      }\n\n      // If we reach here, all retries failed\n\n      // Handle specific error cases\n      if (lastError.response) {\n        // Handle rate limit specifically\n        if (lastError.response.status === 429) {\n          console.warn('Rate limit reached for PUBG API, checking cache for fallback');\n\n          // Check if we have any cached data as fallback\n          const cachedMatch = cacheService.getMatch(matchId, platform);\n          if (cachedMatch) {\n            console.log('Using cached data due to rate limiting');\n            return cachedMatch;\n          }\n          throw new Error('API rate limit exceeded and no cached data available. Please try again later.');\n        } else if (lastError.response.status === 401) {\n          throw new Error('Authentication required');\n        } else {\n          var _lastError$response$d;\n          throw new Error(`API error: ${((_lastError$response$d = lastError.response.data) === null || _lastError$response$d === void 0 ? void 0 : _lastError$response$d.error) || 'Unknown error'}`);\n        }\n      } else if (lastError.code === 'ECONNABORTED') {\n        console.warn('Request timeout, checking cache for fallback');\n        // Check cache as fallback\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data due to timeout');\n          return cachedMatch;\n        }\n        throw new Error('Request timed out. The server might be overloaded.');\n      } else if (lastError.code === 'ECONNRESET') {\n        console.warn('Connection reset by server, checking cache for fallback');\n        // Check cache as fallback\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data due to connection reset');\n          return cachedMatch;\n        }\n        throw new Error('Connection reset by server. Please try again later.');\n      } else if (lastError.request) {\n        // No response received, check cache as fallback\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data due to connection issue');\n          return cachedMatch;\n        }\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw lastError;\n      }\n    } catch (error) {\n      console.error(`Error getting match details: ${matchId}`, error);\n      throw error;\n    }\n  },\n  /**\n   * Get telemetry data for a match with caching\n   * @param {string} matchId - PUBG match ID\n   * @param {string} telemetryUrl - URL to telemetry data (if known)\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API\n   * @returns {Promise<Object>} Telemetry data\n   */\n  async getTelemetry(matchId, telemetryUrl = null, platform = 'steam', bypassCache = false) {\n    const cacheKey = `telemetry_${matchId}`;\n    try {\n      // Check cache first\n      if (!bypassCache) {\n        // We use the regular localStorage for telemetry due to its large size\n        const cachedTelemetry = localStorage.getItem(cacheKey);\n        if (cachedTelemetry) {\n          try {\n            const parsed = JSON.parse(cachedTelemetry);\n            console.log(`Using cached telemetry data for match: ${matchId}`);\n            return parsed;\n          } catch (e) {\n            // Invalid cache, remove it\n            localStorage.removeItem(cacheKey);\n          }\n        }\n      }\n\n      // Get auth token if available\n      const token = authService.getToken();\n\n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // We need to get the telemetry URL first if not provided\n      if (!telemetryUrl) {\n        console.log(`Fetching match data to get telemetry URL: ${matchId}`);\n        // Try to get from cache first\n        let matchData = null;\n        try {\n          matchData = await this.getMatchDetails(matchId, platform, bypassCache);\n\n          // Extract telemetry URL from match data\n          if (matchData.data && matchData.included) {\n            const assets = matchData.included.filter(item => item.type === 'asset');\n            if (assets.length > 0) {\n              var _assets$, _assets$$attributes;\n              telemetryUrl = (_assets$ = assets[0]) === null || _assets$ === void 0 ? void 0 : (_assets$$attributes = _assets$.attributes) === null || _assets$$attributes === void 0 ? void 0 : _assets$$attributes.URL;\n            }\n          }\n        } catch (error) {\n          console.error('Error getting match data for telemetry:', error);\n        }\n        if (!telemetryUrl) {\n          throw new Error('Could not find telemetry URL for this match');\n        }\n      }\n\n      // Make API request to get telemetry data\n      console.log(`Fetching telemetry data for match: ${matchId}`);\n\n      // Use our server endpoint instead of direct telemetry URL\n      // This helps avoid CORS issues and provides better error handling\n      const response = await axios.get(`/api/telemetry/${matchId}?platform=${platform}`, {\n        headers,\n        timeout: 45000 // Extended timeout for large telemetry files\n      });\n\n      // Cache the telemetry data\n      try {\n        localStorage.setItem(cacheKey, JSON.stringify(response.data));\n        console.log(`Cached telemetry data for match: ${matchId}`);\n      } catch (e) {\n        // Local storage might be full - telemetry can be very large\n        console.warn('Could not cache telemetry data - likely too large for localStorage');\n        // Try to clear some space\n        cacheService.clearOldCache();\n      }\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching telemetry:', error);\n\n      // Handle specific error cases\n      if (error.response) {\n        if (error.response.status === 404) {\n          throw new Error('Telemetry data not found');\n        } else if (error.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          var _error$response$data;\n          throw new Error(`API error: ${((_error$response$data = error.response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.error) || 'Unknown error'}`);\n        }\n      } else if (error.code === 'ECONNABORTED') {\n        throw new Error('Request timed out. Telemetry data is large and may take time to load.');\n      } else if (error.code === 'ECONNRESET') {\n        throw new Error('Connection reset by server. Please try again later.');\n      } else if (error.request) {\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        throw error;\n      }\n    }\n  },\n  /**\n   * Search for matches based on criteria with improved reliability\n   * @param {Object} criteria - Search criteria\n   * @returns {Promise<Object>} Search results\n   */\n  async searchMatches(criteria) {\n    try {\n      // Get auth token if available\n      const token = authService.getToken();\n\n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // Implement retry logic with exponential backoff\n      let retries = 2;\n      let lastError = null;\n      while (retries >= 0) {\n        try {\n          console.log(`Searching for matches (attempt ${2 - retries + 1}/3)`);\n\n          // Add a timeout to prevent hanging requests\n          const response = await axios.post('/api/matches/search', criteria, {\n            headers,\n            timeout: 30000 // 30 second timeout for search\n          });\n\n          // Make sure we return the data in the expected format\n          return response.data;\n        } catch (error) {\n          lastError = error;\n\n          // Don't retry if we've exhausted retries\n          if (retries <= 0) {\n            break;\n          }\n\n          // Wait before retry (2s, then 4s)\n          const delay = (3 - retries) * 2000;\n          console.log(`Search failed. Retrying after ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n          retries--;\n        }\n      }\n\n      // If we reach here, all retries failed\n      console.error('All search attempts failed:', lastError);\n\n      // Handle specific error cases\n      if (lastError.response) {\n        // Server responded with an error status\n        if (lastError.response.status === 401) {\n          throw new Error('Authentication required');\n        } else if (lastError.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          var _lastError$response$d2;\n          throw new Error(`API error: ${((_lastError$response$d2 = lastError.response.data) === null || _lastError$response$d2 === void 0 ? void 0 : _lastError$response$d2.error) || lastError.response.statusText || 'Unknown error'}`);\n        }\n      } else if (lastError.code === 'ECONNABORTED') {\n        // Request timed out\n        throw new Error('Request timed out. The server might be overloaded.');\n      } else if (lastError.code === 'ECONNRESET') {\n        // Connection reset by server\n        throw new Error('Connection reset by server. Please try again later.');\n      } else if (lastError.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw lastError;\n      }\n    } catch (error) {\n      console.error('Error in searchMatches:', error);\n      throw error;\n    }\n  },\n  /**\n   * Register a match to a tournament\n   * @param {Object} matchData - Match registration data\n   * @returns {Promise<Object>} Registration result\n   */\n  async registerMatch(matchData) {\n    try {\n      // Get auth token (required for this operation)\n      const token = authService.getToken();\n      if (!token) {\n        throw new Error('Authentication required');\n      }\n\n      // Request headers\n      const headers = {\n        Authorization: `Bearer ${token}`\n      };\n\n      // Make API request with retry logic\n      let retries = 2;\n      let lastError = null;\n      while (retries >= 0) {\n        try {\n          const response = await axios.post('/api/matches/register', matchData, {\n            headers,\n            timeout: 10000 // 10 second timeout\n          });\n          return response.data;\n        } catch (error) {\n          lastError = error;\n\n          // If it's a 404 or 409, don't retry (match not found or already registered)\n          if (error.response && (error.response.status === 404 || error.response.status === 409)) {\n            throw error;\n          }\n\n          // Don't retry if we've exhausted retries\n          if (retries <= 0) {\n            break;\n          }\n\n          // Wait before retry (1s, then 2s)\n          const delay = (2 - retries) * 1000 + 1000;\n          console.log(`Retrying match registration after ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n          retries--;\n        }\n      }\n\n      // If we reach here, all retries failed\n      // Handle specific error cases\n      if (lastError.response) {\n        // Server responded with an error status\n        if (lastError.response.status === 401) {\n          throw new Error('Authentication required');\n        } else if (lastError.response.status === 404) {\n          throw new Error('Match not found');\n        } else if (lastError.response.status === 409) {\n          throw new Error('Match is already registered to a tournament');\n        } else if (lastError.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          var _lastError$response$d3;\n          throw new Error(`API error: ${((_lastError$response$d3 = lastError.response.data) === null || _lastError$response$d3 === void 0 ? void 0 : _lastError$response$d3.error) || 'Unknown error'}`);\n        }\n      } else if (lastError.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw lastError;\n      }\n    } catch (error) {\n      console.error('Error registering match:', error);\n      throw error;\n    }\n  }\n};\nexport default matchesServiceEnhanced;","map":{"version":3,"names":["axios","authService","cacheService","matchesServiceEnhanced","getMatchDetails","matchId","platform","bypassCache","cachedMatch","getMatch","console","log","token","getToken","headers","Authorization","retries","lastError","response","get","timeout","data","Error","storeMatch","error","status","delay","Promise","resolve","setTimeout","warn","_lastError$response$d","code","request","getTelemetry","telemetryUrl","cacheKey","cachedTelemetry","localStorage","getItem","parsed","JSON","parse","e","removeItem","matchData","included","assets","filter","item","type","length","_assets$","_assets$$attributes","attributes","URL","setItem","stringify","clearOldCache","_error$response$data","searchMatches","criteria","post","_lastError$response$d2","statusText","registerMatch","_lastError$response$d3"],"sources":["C:/Users/emil/OneDrive/Documents/development/apiDevelopment/pubg-tournament-tracker/client/src/services/matchesServiceEnhanced.js"],"sourcesContent":["import axios from 'axios';\nimport authService from './authService';\nimport cacheService from './cacheService';\n\n// Create a service for handling match-related API calls with enhanced error handling\nconst matchesServiceEnhanced = {\n  /**\n   * Get match details by ID with caching support and better error handling\n   * @param {string} matchId - PUBG match ID\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API even if cached\n   * @returns {Promise<Object>} Match data\n   */\n  async getMatchDetails(matchId, platform = 'steam', bypassCache = false) {\n    try {\n      // First, check if we have this match cached (unless bypass requested)\n      if (!bypassCache) {\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log(`Using cached data for match: ${matchId}`);\n          return cachedMatch;\n        }\n      }\n      \n      // Get auth token if available\n      const token = authService.getToken();\n      \n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // Make API request with retry logic\n      console.log(`Fetching match data from API: ${matchId}`);\n      let retries = 2;\n      let lastError = null;\n      \n      while (retries >= 0) {\n        try {\n          const response = await axios.get(`/api/matches/${matchId}?platform=${platform}`, { \n            headers,\n            timeout: 15000 // 15 second timeout\n          });\n          \n          // If response is empty or missing key attributes, throw an error\n          if (!response.data || !response.data.data) {\n            throw new Error('Invalid response format from API');\n          }\n          \n          // Cache the successful response\n          cacheService.storeMatch(matchId, platform, response.data);\n          \n          return response.data;\n        } catch (error) {\n          lastError = error;\n          \n          // If it's a 404, don't retry\n          if (error.response && error.response.status === 404) {\n            throw new Error('Match not found');\n          }\n          \n          // Don't retry if we've exhausted retries\n          if (retries <= 0) {\n            break;\n          }\n          \n          // Wait before retry (1s, then 2s)\n          const delay = (2 - retries) * 1000 + 1000;\n          console.log(`Retrying after ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n          \n          retries--;\n        }\n      }\n      \n      // If we reach here, all retries failed\n      \n      // Handle specific error cases\n      if (lastError.response) {\n        // Handle rate limit specifically\n        if (lastError.response.status === 429) {\n          console.warn('Rate limit reached for PUBG API, checking cache for fallback');\n          \n          // Check if we have any cached data as fallback\n          const cachedMatch = cacheService.getMatch(matchId, platform);\n          if (cachedMatch) {\n            console.log('Using cached data due to rate limiting');\n            return cachedMatch;\n          }\n          \n          throw new Error('API rate limit exceeded and no cached data available. Please try again later.');\n        } \n        else if (lastError.response.status === 401) {\n          throw new Error('Authentication required');\n        } else {\n          throw new Error(`API error: ${lastError.response.data?.error || 'Unknown error'}`);\n        }\n      } else if (lastError.code === 'ECONNABORTED') {\n        console.warn('Request timeout, checking cache for fallback');\n        // Check cache as fallback\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data due to timeout');\n          return cachedMatch;\n        }\n        throw new Error('Request timed out. The server might be overloaded.');\n      } else if (lastError.code === 'ECONNRESET') {\n        console.warn('Connection reset by server, checking cache for fallback');\n        // Check cache as fallback\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data due to connection reset');\n          return cachedMatch;\n        }\n        throw new Error('Connection reset by server. Please try again later.');\n      } else if (lastError.request) {\n        // No response received, check cache as fallback\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data due to connection issue');\n          return cachedMatch;\n        }\n        \n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw lastError;\n      }\n    } catch (error) {\n      console.error(`Error getting match details: ${matchId}`, error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Get telemetry data for a match with caching\n   * @param {string} matchId - PUBG match ID\n   * @param {string} telemetryUrl - URL to telemetry data (if known)\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API\n   * @returns {Promise<Object>} Telemetry data\n   */\n  async getTelemetry(matchId, telemetryUrl = null, platform = 'steam', bypassCache = false) {\n    const cacheKey = `telemetry_${matchId}`;\n    \n    try {\n      // Check cache first\n      if (!bypassCache) {\n        // We use the regular localStorage for telemetry due to its large size\n        const cachedTelemetry = localStorage.getItem(cacheKey);\n        if (cachedTelemetry) {\n          try {\n            const parsed = JSON.parse(cachedTelemetry);\n            console.log(`Using cached telemetry data for match: ${matchId}`);\n            return parsed;\n          } catch (e) {\n            // Invalid cache, remove it\n            localStorage.removeItem(cacheKey);\n          }\n        }\n      }\n      \n      // Get auth token if available\n      const token = authService.getToken();\n      \n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // We need to get the telemetry URL first if not provided\n      if (!telemetryUrl) {\n        console.log(`Fetching match data to get telemetry URL: ${matchId}`);\n        // Try to get from cache first\n        let matchData = null;\n        \n        try {\n          matchData = await this.getMatchDetails(matchId, platform, bypassCache);\n          \n          // Extract telemetry URL from match data\n          if (matchData.data && matchData.included) {\n            const assets = matchData.included.filter(item => item.type === 'asset');\n            if (assets.length > 0) {\n              telemetryUrl = assets[0]?.attributes?.URL;\n            }\n          }\n        } catch (error) {\n          console.error('Error getting match data for telemetry:', error);\n        }\n        \n        if (!telemetryUrl) {\n          throw new Error('Could not find telemetry URL for this match');\n        }\n      }\n\n      // Make API request to get telemetry data\n      console.log(`Fetching telemetry data for match: ${matchId}`);\n      \n      // Use our server endpoint instead of direct telemetry URL\n      // This helps avoid CORS issues and provides better error handling\n      const response = await axios.get(`/api/telemetry/${matchId}?platform=${platform}`, { \n        headers,\n        timeout: 45000 // Extended timeout for large telemetry files\n      });\n      \n      // Cache the telemetry data\n      try {\n        localStorage.setItem(cacheKey, JSON.stringify(response.data));\n        console.log(`Cached telemetry data for match: ${matchId}`);\n      } catch (e) {\n        // Local storage might be full - telemetry can be very large\n        console.warn('Could not cache telemetry data - likely too large for localStorage');\n        // Try to clear some space\n        cacheService.clearOldCache();\n      }\n      \n      return response.data;\n    } catch (error) {\n      console.error('Error fetching telemetry:', error);\n      \n      // Handle specific error cases\n      if (error.response) {\n        if (error.response.status === 404) {\n          throw new Error('Telemetry data not found');\n        } else if (error.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          throw new Error(`API error: ${error.response.data?.error || 'Unknown error'}`);\n        }\n      } else if (error.code === 'ECONNABORTED') {\n        throw new Error('Request timed out. Telemetry data is large and may take time to load.');\n      } else if (error.code === 'ECONNRESET') {\n        throw new Error('Connection reset by server. Please try again later.');\n      } else if (error.request) {\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        throw error;\n      }\n    }\n  },\n  \n  /**\n   * Search for matches based on criteria with improved reliability\n   * @param {Object} criteria - Search criteria\n   * @returns {Promise<Object>} Search results\n   */\n  async searchMatches(criteria) {\n    try {\n      // Get auth token if available\n      const token = authService.getToken();\n      \n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // Implement retry logic with exponential backoff\n      let retries = 2;\n      let lastError = null;\n      \n      while (retries >= 0) {\n        try {\n          console.log(`Searching for matches (attempt ${2 - retries + 1}/3)`);\n          \n          // Add a timeout to prevent hanging requests\n          const response = await axios.post('/api/matches/search', criteria, { \n            headers,\n            timeout: 30000 // 30 second timeout for search\n          });\n          \n          // Make sure we return the data in the expected format\n          return response.data;\n        } catch (error) {\n          lastError = error;\n          \n          // Don't retry if we've exhausted retries\n          if (retries <= 0) {\n            break;\n          }\n          \n          // Wait before retry (2s, then 4s)\n          const delay = (3 - retries) * 2000;\n          console.log(`Search failed. Retrying after ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n          \n          retries--;\n        }\n      }\n      \n      // If we reach here, all retries failed\n      console.error('All search attempts failed:', lastError);\n      \n      // Handle specific error cases\n      if (lastError.response) {\n        // Server responded with an error status\n        if (lastError.response.status === 401) {\n          throw new Error('Authentication required');\n        } else if (lastError.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          throw new Error(`API error: ${lastError.response.data?.error || lastError.response.statusText || 'Unknown error'}`);\n        }\n      } else if (lastError.code === 'ECONNABORTED') {\n        // Request timed out\n        throw new Error('Request timed out. The server might be overloaded.');\n      } else if (lastError.code === 'ECONNRESET') {\n        // Connection reset by server\n        throw new Error('Connection reset by server. Please try again later.');\n      } else if (lastError.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw lastError;\n      }\n    } catch (error) {\n      console.error('Error in searchMatches:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Register a match to a tournament\n   * @param {Object} matchData - Match registration data\n   * @returns {Promise<Object>} Registration result\n   */\n  async registerMatch(matchData) {\n    try {\n      // Get auth token (required for this operation)\n      const token = authService.getToken();\n      if (!token) {\n        throw new Error('Authentication required');\n      }\n      \n      // Request headers\n      const headers = {\n        Authorization: `Bearer ${token}`\n      };\n\n      // Make API request with retry logic\n      let retries = 2;\n      let lastError = null;\n      \n      while (retries >= 0) {\n        try {\n          const response = await axios.post('/api/matches/register', matchData, { \n            headers,\n            timeout: 10000 // 10 second timeout\n          });\n          \n          return response.data;\n        } catch (error) {\n          lastError = error;\n          \n          // If it's a 404 or 409, don't retry (match not found or already registered)\n          if (error.response && (error.response.status === 404 || error.response.status === 409)) {\n            throw error;\n          }\n          \n          // Don't retry if we've exhausted retries\n          if (retries <= 0) {\n            break;\n          }\n          \n          // Wait before retry (1s, then 2s)\n          const delay = (2 - retries) * 1000 + 1000;\n          console.log(`Retrying match registration after ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n          \n          retries--;\n        }\n      }\n      \n      // If we reach here, all retries failed\n      // Handle specific error cases\n      if (lastError.response) {\n        // Server responded with an error status\n        if (lastError.response.status === 401) {\n          throw new Error('Authentication required');\n        } else if (lastError.response.status === 404) {\n          throw new Error('Match not found');\n        } else if (lastError.response.status === 409) {\n          throw new Error('Match is already registered to a tournament');\n        } else if (lastError.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          throw new Error(`API error: ${lastError.response.data?.error || 'Unknown error'}`);\n        }\n      } else if (lastError.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw lastError;\n      }\n    } catch (error) {\n      console.error('Error registering match:', error);\n      throw error;\n    }\n  }\n};\n\nexport default matchesServiceEnhanced;"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAOC,WAAW,MAAM,eAAe;AACvC,OAAOC,YAAY,MAAM,gBAAgB;;AAEzC;AACA,MAAMC,sBAAsB,GAAG;EAC7B;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAMC,eAAeA,CAACC,OAAO,EAAEC,QAAQ,GAAG,OAAO,EAAEC,WAAW,GAAG,KAAK,EAAE;IACtE,IAAI;MACF;MACA,IAAI,CAACA,WAAW,EAAE;QAChB,MAAMC,WAAW,GAAGN,YAAY,CAACO,QAAQ,CAACJ,OAAO,EAAEC,QAAQ,CAAC;QAC5D,IAAIE,WAAW,EAAE;UACfE,OAAO,CAACC,GAAG,CAAC,gCAAgCN,OAAO,EAAE,CAAC;UACtD,OAAOG,WAAW;QACpB;MACF;;MAEA;MACA,MAAMI,KAAK,GAAGX,WAAW,CAACY,QAAQ,CAAC,CAAC;;MAEpC;MACA,MAAMC,OAAO,GAAG,CAAC,CAAC;MAClB,IAAIF,KAAK,EAAE;QACTE,OAAO,CAACC,aAAa,GAAG,UAAUH,KAAK,EAAE;MAC3C;;MAEA;MACAF,OAAO,CAACC,GAAG,CAAC,iCAAiCN,OAAO,EAAE,CAAC;MACvD,IAAIW,OAAO,GAAG,CAAC;MACf,IAAIC,SAAS,GAAG,IAAI;MAEpB,OAAOD,OAAO,IAAI,CAAC,EAAE;QACnB,IAAI;UACF,MAAME,QAAQ,GAAG,MAAMlB,KAAK,CAACmB,GAAG,CAAC,gBAAgBd,OAAO,aAAaC,QAAQ,EAAE,EAAE;YAC/EQ,OAAO;YACPM,OAAO,EAAE,KAAK,CAAC;UACjB,CAAC,CAAC;;UAEF;UACA,IAAI,CAACF,QAAQ,CAACG,IAAI,IAAI,CAACH,QAAQ,CAACG,IAAI,CAACA,IAAI,EAAE;YACzC,MAAM,IAAIC,KAAK,CAAC,kCAAkC,CAAC;UACrD;;UAEA;UACApB,YAAY,CAACqB,UAAU,CAAClB,OAAO,EAAEC,QAAQ,EAAEY,QAAQ,CAACG,IAAI,CAAC;UAEzD,OAAOH,QAAQ,CAACG,IAAI;QACtB,CAAC,CAAC,OAAOG,KAAK,EAAE;UACdP,SAAS,GAAGO,KAAK;;UAEjB;UACA,IAAIA,KAAK,CAACN,QAAQ,IAAIM,KAAK,CAACN,QAAQ,CAACO,MAAM,KAAK,GAAG,EAAE;YACnD,MAAM,IAAIH,KAAK,CAAC,iBAAiB,CAAC;UACpC;;UAEA;UACA,IAAIN,OAAO,IAAI,CAAC,EAAE;YAChB;UACF;;UAEA;UACA,MAAMU,KAAK,GAAG,CAAC,CAAC,GAAGV,OAAO,IAAI,IAAI,GAAG,IAAI;UACzCN,OAAO,CAACC,GAAG,CAAC,kBAAkBe,KAAK,OAAO,CAAC;UAC3C,MAAM,IAAIC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEF,KAAK,CAAC,CAAC;UAExDV,OAAO,EAAE;QACX;MACF;;MAEA;;MAEA;MACA,IAAIC,SAAS,CAACC,QAAQ,EAAE;QACtB;QACA,IAAID,SAAS,CAACC,QAAQ,CAACO,MAAM,KAAK,GAAG,EAAE;UACrCf,OAAO,CAACoB,IAAI,CAAC,8DAA8D,CAAC;;UAE5E;UACA,MAAMtB,WAAW,GAAGN,YAAY,CAACO,QAAQ,CAACJ,OAAO,EAAEC,QAAQ,CAAC;UAC5D,IAAIE,WAAW,EAAE;YACfE,OAAO,CAACC,GAAG,CAAC,wCAAwC,CAAC;YACrD,OAAOH,WAAW;UACpB;UAEA,MAAM,IAAIc,KAAK,CAAC,+EAA+E,CAAC;QAClG,CAAC,MACI,IAAIL,SAAS,CAACC,QAAQ,CAACO,MAAM,KAAK,GAAG,EAAE;UAC1C,MAAM,IAAIH,KAAK,CAAC,yBAAyB,CAAC;QAC5C,CAAC,MAAM;UAAA,IAAAS,qBAAA;UACL,MAAM,IAAIT,KAAK,CAAC,cAAc,EAAAS,qBAAA,GAAAd,SAAS,CAACC,QAAQ,CAACG,IAAI,cAAAU,qBAAA,uBAAvBA,qBAAA,CAAyBP,KAAK,KAAI,eAAe,EAAE,CAAC;QACpF;MACF,CAAC,MAAM,IAAIP,SAAS,CAACe,IAAI,KAAK,cAAc,EAAE;QAC5CtB,OAAO,CAACoB,IAAI,CAAC,8CAA8C,CAAC;QAC5D;QACA,MAAMtB,WAAW,GAAGN,YAAY,CAACO,QAAQ,CAACJ,OAAO,EAAEC,QAAQ,CAAC;QAC5D,IAAIE,WAAW,EAAE;UACfE,OAAO,CAACC,GAAG,CAAC,kCAAkC,CAAC;UAC/C,OAAOH,WAAW;QACpB;QACA,MAAM,IAAIc,KAAK,CAAC,oDAAoD,CAAC;MACvE,CAAC,MAAM,IAAIL,SAAS,CAACe,IAAI,KAAK,YAAY,EAAE;QAC1CtB,OAAO,CAACoB,IAAI,CAAC,yDAAyD,CAAC;QACvE;QACA,MAAMtB,WAAW,GAAGN,YAAY,CAACO,QAAQ,CAACJ,OAAO,EAAEC,QAAQ,CAAC;QAC5D,IAAIE,WAAW,EAAE;UACfE,OAAO,CAACC,GAAG,CAAC,2CAA2C,CAAC;UACxD,OAAOH,WAAW;QACpB;QACA,MAAM,IAAIc,KAAK,CAAC,qDAAqD,CAAC;MACxE,CAAC,MAAM,IAAIL,SAAS,CAACgB,OAAO,EAAE;QAC5B;QACA,MAAMzB,WAAW,GAAGN,YAAY,CAACO,QAAQ,CAACJ,OAAO,EAAEC,QAAQ,CAAC;QAC5D,IAAIE,WAAW,EAAE;UACfE,OAAO,CAACC,GAAG,CAAC,2CAA2C,CAAC;UACxD,OAAOH,WAAW;QACpB;QAEA,MAAM,IAAIc,KAAK,CAAC,wDAAwD,CAAC;MAC3E,CAAC,MAAM;QACL;QACA,MAAML,SAAS;MACjB;IACF,CAAC,CAAC,OAAOO,KAAK,EAAE;MACdd,OAAO,CAACc,KAAK,CAAC,gCAAgCnB,OAAO,EAAE,EAAEmB,KAAK,CAAC;MAC/D,MAAMA,KAAK;IACb;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMU,YAAYA,CAAC7B,OAAO,EAAE8B,YAAY,GAAG,IAAI,EAAE7B,QAAQ,GAAG,OAAO,EAAEC,WAAW,GAAG,KAAK,EAAE;IACxF,MAAM6B,QAAQ,GAAG,aAAa/B,OAAO,EAAE;IAEvC,IAAI;MACF;MACA,IAAI,CAACE,WAAW,EAAE;QAChB;QACA,MAAM8B,eAAe,GAAGC,YAAY,CAACC,OAAO,CAACH,QAAQ,CAAC;QACtD,IAAIC,eAAe,EAAE;UACnB,IAAI;YACF,MAAMG,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACL,eAAe,CAAC;YAC1C3B,OAAO,CAACC,GAAG,CAAC,0CAA0CN,OAAO,EAAE,CAAC;YAChE,OAAOmC,MAAM;UACf,CAAC,CAAC,OAAOG,CAAC,EAAE;YACV;YACAL,YAAY,CAACM,UAAU,CAACR,QAAQ,CAAC;UACnC;QACF;MACF;;MAEA;MACA,MAAMxB,KAAK,GAAGX,WAAW,CAACY,QAAQ,CAAC,CAAC;;MAEpC;MACA,MAAMC,OAAO,GAAG,CAAC,CAAC;MAClB,IAAIF,KAAK,EAAE;QACTE,OAAO,CAACC,aAAa,GAAG,UAAUH,KAAK,EAAE;MAC3C;;MAEA;MACA,IAAI,CAACuB,YAAY,EAAE;QACjBzB,OAAO,CAACC,GAAG,CAAC,6CAA6CN,OAAO,EAAE,CAAC;QACnE;QACA,IAAIwC,SAAS,GAAG,IAAI;QAEpB,IAAI;UACFA,SAAS,GAAG,MAAM,IAAI,CAACzC,eAAe,CAACC,OAAO,EAAEC,QAAQ,EAAEC,WAAW,CAAC;;UAEtE;UACA,IAAIsC,SAAS,CAACxB,IAAI,IAAIwB,SAAS,CAACC,QAAQ,EAAE;YACxC,MAAMC,MAAM,GAAGF,SAAS,CAACC,QAAQ,CAACE,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACC,IAAI,KAAK,OAAO,CAAC;YACvE,IAAIH,MAAM,CAACI,MAAM,GAAG,CAAC,EAAE;cAAA,IAAAC,QAAA,EAAAC,mBAAA;cACrBlB,YAAY,IAAAiB,QAAA,GAAGL,MAAM,CAAC,CAAC,CAAC,cAAAK,QAAA,wBAAAC,mBAAA,GAATD,QAAA,CAAWE,UAAU,cAAAD,mBAAA,uBAArBA,mBAAA,CAAuBE,GAAG;YAC3C;UACF;QACF,CAAC,CAAC,OAAO/B,KAAK,EAAE;UACdd,OAAO,CAACc,KAAK,CAAC,yCAAyC,EAAEA,KAAK,CAAC;QACjE;QAEA,IAAI,CAACW,YAAY,EAAE;UACjB,MAAM,IAAIb,KAAK,CAAC,6CAA6C,CAAC;QAChE;MACF;;MAEA;MACAZ,OAAO,CAACC,GAAG,CAAC,sCAAsCN,OAAO,EAAE,CAAC;;MAE5D;MACA;MACA,MAAMa,QAAQ,GAAG,MAAMlB,KAAK,CAACmB,GAAG,CAAC,kBAAkBd,OAAO,aAAaC,QAAQ,EAAE,EAAE;QACjFQ,OAAO;QACPM,OAAO,EAAE,KAAK,CAAC;MACjB,CAAC,CAAC;;MAEF;MACA,IAAI;QACFkB,YAAY,CAACkB,OAAO,CAACpB,QAAQ,EAAEK,IAAI,CAACgB,SAAS,CAACvC,QAAQ,CAACG,IAAI,CAAC,CAAC;QAC7DX,OAAO,CAACC,GAAG,CAAC,oCAAoCN,OAAO,EAAE,CAAC;MAC5D,CAAC,CAAC,OAAOsC,CAAC,EAAE;QACV;QACAjC,OAAO,CAACoB,IAAI,CAAC,oEAAoE,CAAC;QAClF;QACA5B,YAAY,CAACwD,aAAa,CAAC,CAAC;MAC9B;MAEA,OAAOxC,QAAQ,CAACG,IAAI;IACtB,CAAC,CAAC,OAAOG,KAAK,EAAE;MACdd,OAAO,CAACc,KAAK,CAAC,2BAA2B,EAAEA,KAAK,CAAC;;MAEjD;MACA,IAAIA,KAAK,CAACN,QAAQ,EAAE;QAClB,IAAIM,KAAK,CAACN,QAAQ,CAACO,MAAM,KAAK,GAAG,EAAE;UACjC,MAAM,IAAIH,KAAK,CAAC,0BAA0B,CAAC;QAC7C,CAAC,MAAM,IAAIE,KAAK,CAACN,QAAQ,CAACO,MAAM,KAAK,GAAG,EAAE;UACxC,MAAM,IAAIH,KAAK,CAAC,kDAAkD,CAAC;QACrE,CAAC,MAAM;UAAA,IAAAqC,oBAAA;UACL,MAAM,IAAIrC,KAAK,CAAC,cAAc,EAAAqC,oBAAA,GAAAnC,KAAK,CAACN,QAAQ,CAACG,IAAI,cAAAsC,oBAAA,uBAAnBA,oBAAA,CAAqBnC,KAAK,KAAI,eAAe,EAAE,CAAC;QAChF;MACF,CAAC,MAAM,IAAIA,KAAK,CAACQ,IAAI,KAAK,cAAc,EAAE;QACxC,MAAM,IAAIV,KAAK,CAAC,uEAAuE,CAAC;MAC1F,CAAC,MAAM,IAAIE,KAAK,CAACQ,IAAI,KAAK,YAAY,EAAE;QACtC,MAAM,IAAIV,KAAK,CAAC,qDAAqD,CAAC;MACxE,CAAC,MAAM,IAAIE,KAAK,CAACS,OAAO,EAAE;QACxB,MAAM,IAAIX,KAAK,CAAC,wDAAwD,CAAC;MAC3E,CAAC,MAAM;QACL,MAAME,KAAK;MACb;IACF;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;EACE,MAAMoC,aAAaA,CAACC,QAAQ,EAAE;IAC5B,IAAI;MACF;MACA,MAAMjD,KAAK,GAAGX,WAAW,CAACY,QAAQ,CAAC,CAAC;;MAEpC;MACA,MAAMC,OAAO,GAAG,CAAC,CAAC;MAClB,IAAIF,KAAK,EAAE;QACTE,OAAO,CAACC,aAAa,GAAG,UAAUH,KAAK,EAAE;MAC3C;;MAEA;MACA,IAAII,OAAO,GAAG,CAAC;MACf,IAAIC,SAAS,GAAG,IAAI;MAEpB,OAAOD,OAAO,IAAI,CAAC,EAAE;QACnB,IAAI;UACFN,OAAO,CAACC,GAAG,CAAC,kCAAkC,CAAC,GAAGK,OAAO,GAAG,CAAC,KAAK,CAAC;;UAEnE;UACA,MAAME,QAAQ,GAAG,MAAMlB,KAAK,CAAC8D,IAAI,CAAC,qBAAqB,EAAED,QAAQ,EAAE;YACjE/C,OAAO;YACPM,OAAO,EAAE,KAAK,CAAC;UACjB,CAAC,CAAC;;UAEF;UACA,OAAOF,QAAQ,CAACG,IAAI;QACtB,CAAC,CAAC,OAAOG,KAAK,EAAE;UACdP,SAAS,GAAGO,KAAK;;UAEjB;UACA,IAAIR,OAAO,IAAI,CAAC,EAAE;YAChB;UACF;;UAEA;UACA,MAAMU,KAAK,GAAG,CAAC,CAAC,GAAGV,OAAO,IAAI,IAAI;UAClCN,OAAO,CAACC,GAAG,CAAC,iCAAiCe,KAAK,OAAO,CAAC;UAC1D,MAAM,IAAIC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEF,KAAK,CAAC,CAAC;UAExDV,OAAO,EAAE;QACX;MACF;;MAEA;MACAN,OAAO,CAACc,KAAK,CAAC,6BAA6B,EAAEP,SAAS,CAAC;;MAEvD;MACA,IAAIA,SAAS,CAACC,QAAQ,EAAE;QACtB;QACA,IAAID,SAAS,CAACC,QAAQ,CAACO,MAAM,KAAK,GAAG,EAAE;UACrC,MAAM,IAAIH,KAAK,CAAC,yBAAyB,CAAC;QAC5C,CAAC,MAAM,IAAIL,SAAS,CAACC,QAAQ,CAACO,MAAM,KAAK,GAAG,EAAE;UAC5C,MAAM,IAAIH,KAAK,CAAC,kDAAkD,CAAC;QACrE,CAAC,MAAM;UAAA,IAAAyC,sBAAA;UACL,MAAM,IAAIzC,KAAK,CAAC,cAAc,EAAAyC,sBAAA,GAAA9C,SAAS,CAACC,QAAQ,CAACG,IAAI,cAAA0C,sBAAA,uBAAvBA,sBAAA,CAAyBvC,KAAK,KAAIP,SAAS,CAACC,QAAQ,CAAC8C,UAAU,IAAI,eAAe,EAAE,CAAC;QACrH;MACF,CAAC,MAAM,IAAI/C,SAAS,CAACe,IAAI,KAAK,cAAc,EAAE;QAC5C;QACA,MAAM,IAAIV,KAAK,CAAC,oDAAoD,CAAC;MACvE,CAAC,MAAM,IAAIL,SAAS,CAACe,IAAI,KAAK,YAAY,EAAE;QAC1C;QACA,MAAM,IAAIV,KAAK,CAAC,qDAAqD,CAAC;MACxE,CAAC,MAAM,IAAIL,SAAS,CAACgB,OAAO,EAAE;QAC5B;QACA,MAAM,IAAIX,KAAK,CAAC,wDAAwD,CAAC;MAC3E,CAAC,MAAM;QACL;QACA,MAAML,SAAS;MACjB;IACF,CAAC,CAAC,OAAOO,KAAK,EAAE;MACdd,OAAO,CAACc,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MAC/C,MAAMA,KAAK;IACb;EACF,CAAC;EAED;AACF;AACA;AACA;AACA;EACE,MAAMyC,aAAaA,CAACpB,SAAS,EAAE;IAC7B,IAAI;MACF;MACA,MAAMjC,KAAK,GAAGX,WAAW,CAACY,QAAQ,CAAC,CAAC;MACpC,IAAI,CAACD,KAAK,EAAE;QACV,MAAM,IAAIU,KAAK,CAAC,yBAAyB,CAAC;MAC5C;;MAEA;MACA,MAAMR,OAAO,GAAG;QACdC,aAAa,EAAE,UAAUH,KAAK;MAChC,CAAC;;MAED;MACA,IAAII,OAAO,GAAG,CAAC;MACf,IAAIC,SAAS,GAAG,IAAI;MAEpB,OAAOD,OAAO,IAAI,CAAC,EAAE;QACnB,IAAI;UACF,MAAME,QAAQ,GAAG,MAAMlB,KAAK,CAAC8D,IAAI,CAAC,uBAAuB,EAAEjB,SAAS,EAAE;YACpE/B,OAAO;YACPM,OAAO,EAAE,KAAK,CAAC;UACjB,CAAC,CAAC;UAEF,OAAOF,QAAQ,CAACG,IAAI;QACtB,CAAC,CAAC,OAAOG,KAAK,EAAE;UACdP,SAAS,GAAGO,KAAK;;UAEjB;UACA,IAAIA,KAAK,CAACN,QAAQ,KAAKM,KAAK,CAACN,QAAQ,CAACO,MAAM,KAAK,GAAG,IAAID,KAAK,CAACN,QAAQ,CAACO,MAAM,KAAK,GAAG,CAAC,EAAE;YACtF,MAAMD,KAAK;UACb;;UAEA;UACA,IAAIR,OAAO,IAAI,CAAC,EAAE;YAChB;UACF;;UAEA;UACA,MAAMU,KAAK,GAAG,CAAC,CAAC,GAAGV,OAAO,IAAI,IAAI,GAAG,IAAI;UACzCN,OAAO,CAACC,GAAG,CAAC,qCAAqCe,KAAK,OAAO,CAAC;UAC9D,MAAM,IAAIC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEF,KAAK,CAAC,CAAC;UAExDV,OAAO,EAAE;QACX;MACF;;MAEA;MACA;MACA,IAAIC,SAAS,CAACC,QAAQ,EAAE;QACtB;QACA,IAAID,SAAS,CAACC,QAAQ,CAACO,MAAM,KAAK,GAAG,EAAE;UACrC,MAAM,IAAIH,KAAK,CAAC,yBAAyB,CAAC;QAC5C,CAAC,MAAM,IAAIL,SAAS,CAACC,QAAQ,CAACO,MAAM,KAAK,GAAG,EAAE;UAC5C,MAAM,IAAIH,KAAK,CAAC,iBAAiB,CAAC;QACpC,CAAC,MAAM,IAAIL,SAAS,CAACC,QAAQ,CAACO,MAAM,KAAK,GAAG,EAAE;UAC5C,MAAM,IAAIH,KAAK,CAAC,6CAA6C,CAAC;QAChE,CAAC,MAAM,IAAIL,SAAS,CAACC,QAAQ,CAACO,MAAM,KAAK,GAAG,EAAE;UAC5C,MAAM,IAAIH,KAAK,CAAC,kDAAkD,CAAC;QACrE,CAAC,MAAM;UAAA,IAAA4C,sBAAA;UACL,MAAM,IAAI5C,KAAK,CAAC,cAAc,EAAA4C,sBAAA,GAAAjD,SAAS,CAACC,QAAQ,CAACG,IAAI,cAAA6C,sBAAA,uBAAvBA,sBAAA,CAAyB1C,KAAK,KAAI,eAAe,EAAE,CAAC;QACpF;MACF,CAAC,MAAM,IAAIP,SAAS,CAACgB,OAAO,EAAE;QAC5B;QACA,MAAM,IAAIX,KAAK,CAAC,wDAAwD,CAAC;MAC3E,CAAC,MAAM;QACL;QACA,MAAML,SAAS;MACjB;IACF,CAAC,CAAC,OAAOO,KAAK,EAAE;MACdd,OAAO,CAACc,KAAK,CAAC,0BAA0B,EAAEA,KAAK,CAAC;MAChD,MAAMA,KAAK;IACb;EACF;AACF,CAAC;AAED,eAAerB,sBAAsB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}