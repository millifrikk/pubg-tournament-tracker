{"ast":null,"code":"/**\n * Match classification utilities\n */\n\n/**\n * Determine match type based on PUBG API response data\n * @param {Object} matchData - Match data from PUBG API\n * @returns {String} Match type (RANKED, CUSTOM, or PUBLIC)\n */\nexport const getMatchType = matchData => {\n  if (!matchData || !matchData.data || !matchData.data.attributes) {\n    return 'PUBLIC';\n  }\n  const attributes = matchData.data.attributes;\n\n  // Use the matchType attribute as the primary classification method\n  if (attributes.matchType === 'competitive') {\n    return 'RANKED';\n  } else if (attributes.matchType === 'custom' || attributes.isCustomMatch === true) {\n    return 'CUSTOM';\n  } else if (attributes.matchType === 'official') {\n    return 'PUBLIC';\n  }\n\n  // Return meta info if available (this is from our server)\n  if (matchData.meta && matchData.meta.matchType) {\n    return matchData.meta.matchType;\n  }\n\n  // For any other case, default to PUBLIC\n  return 'PUBLIC';\n};\n\n/**\n * Get a human-readable description of match type\n * @param {String} matchType - Match type (RANKED, CUSTOM, or PUBLIC)\n * @returns {String} Human-readable description\n */\nexport const getMatchTypeDescription = matchType => {\n  switch (matchType) {\n    case 'RANKED':\n      return 'Ranked Match';\n    case 'CUSTOM':\n      return 'Custom Match';\n    case 'PUBLIC':\n      return 'Public Match';\n    default:\n      return 'Unknown Type';\n  }\n};\n\n/**\n * Get CSS class for match type\n * @param {String} matchType - Match type (RANKED, CUSTOM, or PUBLIC)\n * @returns {String} CSS class\n */\nexport const getMatchTypeClass = matchType => {\n  switch (matchType) {\n    case 'RANKED':\n      return 'ranked-match';\n    case 'CUSTOM':\n      return 'custom-match';\n    case 'PUBLIC':\n      return 'public-match';\n    default:\n      return '';\n  }\n};\n\n/**\n * Format match timestamps\n * @param {String} dateString - Date string from API\n * @returns {String} Formatted date string\n */\nexport const formatMatchDate = dateString => {\n  const options = {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit'\n  };\n  return new Date(dateString).toLocaleDateString(undefined, options);\n};\n\n/**\n * Get relative time (e.g., \"2 hours ago\", \"3 days ago\")\n * @param {String} dateString - Date string from API\n * @returns {String} Relative time string\n */\nexport const getRelativeTime = dateString => {\n  const matchDate = new Date(dateString);\n  const now = new Date();\n\n  // Calculate the time difference in milliseconds\n  const timeDiff = now - matchDate;\n\n  // Convert to seconds, minutes, hours, days\n  const secondsDiff = Math.floor(timeDiff / 1000);\n  const minutesDiff = Math.floor(secondsDiff / 60);\n  const hoursDiff = Math.floor(minutesDiff / 60);\n  const daysDiff = Math.floor(hoursDiff / 24);\n  const weeksDiff = Math.floor(daysDiff / 7);\n  const monthsDiff = Math.floor(daysDiff / 30);\n\n  // Return appropriate string based on time difference\n  if (secondsDiff < 60) {\n    return 'just now';\n  } else if (minutesDiff < 60) {\n    return `${minutesDiff} ${minutesDiff === 1 ? 'minute' : 'minutes'} ago`;\n  } else if (hoursDiff < 24) {\n    return `${hoursDiff} ${hoursDiff === 1 ? 'hour' : 'hours'} ago`;\n  } else if (daysDiff < 7) {\n    return `${daysDiff} ${daysDiff === 1 ? 'day' : 'days'} ago`;\n  } else if (weeksDiff < 4) {\n    return `${weeksDiff} ${weeksDiff === 1 ? 'week' : 'weeks'} ago`;\n  } else if (monthsDiff < 12) {\n    return `${monthsDiff} ${monthsDiff === 1 ? 'month' : 'months'} ago`;\n  } else {\n    const yearsDiff = Math.floor(monthsDiff / 12);\n    return `${yearsDiff} ${yearsDiff === 1 ? 'year' : 'years'} ago`;\n  }\n};\n\n/**\n * Get human-readable display of match duration\n * @param {Number} seconds - Duration in seconds\n * @returns {String} Formatted duration (MM:SS)\n */\nexport const formatMatchDuration = seconds => {\n  if (!seconds) return 'Unknown';\n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = seconds % 60;\n  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\n};","map":{"version":3,"names":["getMatchType","matchData","data","attributes","matchType","isCustomMatch","meta","getMatchTypeDescription","getMatchTypeClass","formatMatchDate","dateString","options","year","month","day","hour","minute","Date","toLocaleDateString","undefined","getRelativeTime","matchDate","now","timeDiff","secondsDiff","Math","floor","minutesDiff","hoursDiff","daysDiff","weeksDiff","monthsDiff","yearsDiff","formatMatchDuration","seconds","minutes","remainingSeconds","toString","padStart"],"sources":["C:/Users/emil/OneDrive/Documents/development/apiDevelopment/pubg-tournament-tracker/client/src/utils/matchUtils.js"],"sourcesContent":["/**\n * Match classification utilities\n */\n\n/**\n * Determine match type based on PUBG API response data\n * @param {Object} matchData - Match data from PUBG API\n * @returns {String} Match type (RANKED, CUSTOM, or PUBLIC)\n */\nexport const getMatchType = (matchData) => {\n  if (!matchData || !matchData.data || !matchData.data.attributes) {\n    return 'PUBLIC';\n  }\n  \n  const attributes = matchData.data.attributes;\n  \n  // Use the matchType attribute as the primary classification method\n  if (attributes.matchType === 'competitive') {\n    return 'RANKED';\n  } else if (attributes.matchType === 'custom' || attributes.isCustomMatch === true) {\n    return 'CUSTOM';\n  } else if (attributes.matchType === 'official') {\n    return 'PUBLIC';\n  }\n  \n  // Return meta info if available (this is from our server)\n  if (matchData.meta && matchData.meta.matchType) {\n    return matchData.meta.matchType;\n  }\n  \n  // For any other case, default to PUBLIC\n  return 'PUBLIC';\n};\n\n/**\n * Get a human-readable description of match type\n * @param {String} matchType - Match type (RANKED, CUSTOM, or PUBLIC)\n * @returns {String} Human-readable description\n */\nexport const getMatchTypeDescription = (matchType) => {\n  switch (matchType) {\n    case 'RANKED':\n      return 'Ranked Match';\n    case 'CUSTOM':\n      return 'Custom Match';\n    case 'PUBLIC':\n      return 'Public Match';\n    default:\n      return 'Unknown Type';\n  }\n};\n\n/**\n * Get CSS class for match type\n * @param {String} matchType - Match type (RANKED, CUSTOM, or PUBLIC)\n * @returns {String} CSS class\n */\nexport const getMatchTypeClass = (matchType) => {\n  switch (matchType) {\n    case 'RANKED':\n      return 'ranked-match';\n    case 'CUSTOM':\n      return 'custom-match';\n    case 'PUBLIC':\n      return 'public-match';\n    default:\n      return '';\n  }\n};\n\n/**\n * Format match timestamps\n * @param {String} dateString - Date string from API\n * @returns {String} Formatted date string\n */\nexport const formatMatchDate = (dateString) => {\n  const options = { \n    year: 'numeric', \n    month: 'short', \n    day: 'numeric', \n    hour: '2-digit', \n    minute: '2-digit' \n  };\n  return new Date(dateString).toLocaleDateString(undefined, options);\n};\n\n/**\n * Get relative time (e.g., \"2 hours ago\", \"3 days ago\")\n * @param {String} dateString - Date string from API\n * @returns {String} Relative time string\n */\nexport const getRelativeTime = (dateString) => {\n  const matchDate = new Date(dateString);\n  const now = new Date();\n  \n  // Calculate the time difference in milliseconds\n  const timeDiff = now - matchDate;\n  \n  // Convert to seconds, minutes, hours, days\n  const secondsDiff = Math.floor(timeDiff / 1000);\n  const minutesDiff = Math.floor(secondsDiff / 60);\n  const hoursDiff = Math.floor(minutesDiff / 60);\n  const daysDiff = Math.floor(hoursDiff / 24);\n  const weeksDiff = Math.floor(daysDiff / 7);\n  const monthsDiff = Math.floor(daysDiff / 30);\n  \n  // Return appropriate string based on time difference\n  if (secondsDiff < 60) {\n    return 'just now';\n  } else if (minutesDiff < 60) {\n    return `${minutesDiff} ${minutesDiff === 1 ? 'minute' : 'minutes'} ago`;\n  } else if (hoursDiff < 24) {\n    return `${hoursDiff} ${hoursDiff === 1 ? 'hour' : 'hours'} ago`;\n  } else if (daysDiff < 7) {\n    return `${daysDiff} ${daysDiff === 1 ? 'day' : 'days'} ago`;\n  } else if (weeksDiff < 4) {\n    return `${weeksDiff} ${weeksDiff === 1 ? 'week' : 'weeks'} ago`;\n  } else if (monthsDiff < 12) {\n    return `${monthsDiff} ${monthsDiff === 1 ? 'month' : 'months'} ago`;\n  } else {\n    const yearsDiff = Math.floor(monthsDiff / 12);\n    return `${yearsDiff} ${yearsDiff === 1 ? 'year' : 'years'} ago`;\n  }\n};\n\n/**\n * Get human-readable display of match duration\n * @param {Number} seconds - Duration in seconds\n * @returns {String} Formatted duration (MM:SS)\n */\nexport const formatMatchDuration = (seconds) => {\n  if (!seconds) return 'Unknown';\n  \n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = seconds % 60;\n  \n  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}