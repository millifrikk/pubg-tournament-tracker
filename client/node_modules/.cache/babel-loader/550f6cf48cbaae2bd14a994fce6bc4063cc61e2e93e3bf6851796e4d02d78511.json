{"ast":null,"code":"import axios from 'axios';\nimport authService from './authService';\n\n// Import the cache service if available\nlet cacheService;\ntry {\n  cacheService = require('./cacheService').default;\n} catch (e) {\n  // Create a simple cache if the service doesn't exist\n  cacheService = {\n    getMatch: () => null,\n    storeMatch: () => {},\n    clearOldCache: () => {}\n  };\n  console.warn('CacheService not available, using fallback cache');\n}\nclass MatchesServiceEnhanced {\n  /**\n   * Search for matches with enhanced error handling and retry logic\n   * @param {Object} criteria - Search criteria \n   * @returns {Promise<Object>} Search results\n   */\n  async searchMatches(criteria) {\n    try {\n      // Get auth token if available\n      const token = authService.getToken();\n\n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // Implement retry logic with exponential backoff\n      let retries = 2;\n      let lastError = null;\n      while (retries >= 0) {\n        try {\n          console.log(`Searching for matches (attempt ${2 - retries + 1}/3)`);\n\n          // Add a timeout to prevent hanging requests\n          const response = await axios.post('/api/matches/search', criteria, {\n            headers,\n            timeout: 30000 // 30 second timeout for search\n          });\n\n          // Make sure we return the data in the expected format\n          return response.data;\n        } catch (error) {\n          lastError = error;\n\n          // If it's a 404 or other specific error, don't retry\n          if (error.response && error.response.status === 404) {\n            throw error;\n          }\n\n          // Don't retry if we've exhausted retries\n          if (retries <= 0) {\n            break;\n          }\n\n          // Wait before retry (2s, then 4s)\n          const delay = (3 - retries) * 2000;\n          console.log(`Search failed. Retrying after ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n          retries--;\n        }\n      }\n\n      // If we reach here, all retries failed\n      console.error('All search attempts failed:', lastError);\n\n      // Handle specific error cases\n      if (lastError.response) {\n        // Server responded with an error status\n        if (lastError.response.status === 401) {\n          throw new Error('Authentication required');\n        } else if (lastError.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          var _lastError$response$d;\n          throw new Error(`API error: ${((_lastError$response$d = lastError.response.data) === null || _lastError$response$d === void 0 ? void 0 : _lastError$response$d.error) || lastError.response.statusText || 'Unknown error'}`);\n        }\n      } else if (lastError.code === 'ECONNABORTED') {\n        // Request timed out\n        throw new Error('Request timed out. The server might be overloaded or try a more specific search.');\n      } else if (lastError.code === 'ECONNRESET') {\n        // Connection reset by server\n        throw new Error('Connection reset by server. Please try a more specific search with fewer results.');\n      } else if (lastError.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection and try again.');\n      } else {\n        // Something else went wrong\n        throw lastError;\n      }\n    } catch (error) {\n      console.error('Error in searchMatches:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get match details by ID with enhanced error handling, retry logic and caching\n   * @param {string} matchId - PUBG match ID\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API even if cached\n   * @returns {Promise<Object>} Match data\n   */\n  async getMatchDetails(matchId, platform = 'steam', bypassCache = false) {\n    try {\n      // First, check if we have this match cached (unless bypass requested)\n      if (!bypassCache && cacheService) {\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log(`Using cached data for match: ${matchId}`);\n          return cachedMatch;\n        }\n      }\n\n      // Get auth token if available\n      const token = authService.getToken();\n\n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // Implement retry logic with exponential backoff\n      let retries = 2;\n      let lastError = null;\n      while (retries >= 0) {\n        try {\n          console.log(`Fetching match data from API: ${matchId} (attempt ${2 - retries + 1}/3)`);\n\n          // Make API request with timeout\n          const response = await axios.get(`/api/matches/${matchId}?platform=${platform}`, {\n            headers,\n            timeout: 30000 // 30 second timeout\n          });\n\n          // If response is empty or missing key attributes, throw an error\n          if (!response.data || !response.data.data) {\n            throw new Error('Invalid response format from API');\n          }\n\n          // Cache the successful response\n          if (cacheService) {\n            cacheService.storeMatch(matchId, platform, response.data);\n          }\n          return response.data;\n        } catch (error) {\n          lastError = error;\n\n          // If it's a 404, don't retry\n          if (error.response && error.response.status === 404) {\n            throw new Error('Match not found');\n          }\n\n          // Don't retry if we've exhausted retries\n          if (retries <= 0) {\n            break;\n          }\n\n          // For rate limiting, wait longer\n          if (error.response && error.response.status === 429) {\n            // Check cache as fallback for rate limiting\n            if (cacheService) {\n              const cachedMatch = cacheService.getMatch(matchId, platform);\n              if (cachedMatch) {\n                console.log('Using cached data due to rate limiting');\n                return cachedMatch;\n              }\n            }\n            const delay = 5000; // 5 seconds for rate limit\n            console.log(`Rate limit hit. Waiting ${delay}ms before retry...`);\n            await new Promise(resolve => setTimeout(resolve, delay));\n          } else {\n            // Regular exponential backoff for other errors\n            const delay = (3 - retries) * 2000;\n            console.log(`Request failed. Retrying after ${delay}ms...`);\n            await new Promise(resolve => setTimeout(resolve, delay));\n          }\n          retries--;\n        }\n      }\n\n      // If we reach here, all retries failed\n      console.error('All match detail requests failed:', lastError);\n\n      // Check if we have any cached data as fallback\n      if (cacheService) {\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data after all retries failed');\n          return cachedMatch;\n        }\n      }\n\n      // Handle specific error cases\n      if (lastError.response) {\n        if (lastError.response.status === 404) {\n          throw new Error('Match not found');\n        } else if (lastError.response.status === 429) {\n          throw new Error('API rate limit exceeded and no cached data available. Please try again later.');\n        } else if (lastError.response.status === 401) {\n          throw new Error('Authentication required');\n        } else {\n          var _lastError$response$d2;\n          throw new Error(`API error: ${((_lastError$response$d2 = lastError.response.data) === null || _lastError$response$d2 === void 0 ? void 0 : _lastError$response$d2.error) || 'Unknown error'}`);\n        }\n      } else if (lastError.code === 'ECONNABORTED') {\n        // Request timed out\n        throw new Error('Request timed out. The server might be overloaded.');\n      } else if (lastError.code === 'ECONNRESET') {\n        // Connection reset by server\n        throw new Error('Connection reset by server. Please try again later.');\n      } else if (lastError.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw lastError;\n      }\n    } catch (error) {\n      console.error('Error in getMatchDetails:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get telemetry data for a match with enhanced error handling and caching\n   * @param {string} matchId - PUBG match ID\n   * @param {string} telemetryUrl - URL to telemetry data (if known)\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API\n   * @returns {Promise<Object>} Telemetry data\n   */\n  async getTelemetry(matchId, telemetryUrl = null, platform = 'steam', bypassCache = false) {\n    const cacheKey = `telemetry_${matchId}`;\n    try {\n      // Check cache first\n      if (!bypassCache) {\n        // We use the regular localStorage for telemetry due to its large size\n        const cachedTelemetry = localStorage.getItem(cacheKey);\n        if (cachedTelemetry) {\n          try {\n            const parsed = JSON.parse(cachedTelemetry);\n            console.log(`Using cached telemetry data for match: ${matchId}`);\n            return parsed;\n          } catch (e) {\n            // Invalid cache, remove it\n            localStorage.removeItem(cacheKey);\n          }\n        }\n      }\n\n      // Get auth token if available\n      const token = authService.getToken();\n\n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // We need to get the telemetry URL first if not provided\n      if (!telemetryUrl) {\n        console.log(`Fetching match data to get telemetry URL: ${matchId}`);\n        // Try to get from cache first\n        let matchData = null;\n        try {\n          matchData = await this.getMatchDetails(matchId, platform, bypassCache);\n\n          // Extract telemetry URL from match data\n          if (matchData.data && matchData.included) {\n            const assets = matchData.included.filter(item => item.type === 'asset');\n            if (assets.length > 0) {\n              var _assets$, _assets$$attributes;\n              telemetryUrl = (_assets$ = assets[0]) === null || _assets$ === void 0 ? void 0 : (_assets$$attributes = _assets$.attributes) === null || _assets$$attributes === void 0 ? void 0 : _assets$$attributes.URL;\n            }\n          }\n        } catch (error) {\n          console.error('Error getting match data for telemetry:', error);\n        }\n        if (!telemetryUrl) {\n          throw new Error('Could not find telemetry URL for this match');\n        }\n      }\n\n      // Implement retry logic with exponential backoff\n      let retries = 2;\n      let lastError = null;\n      while (retries >= 0) {\n        try {\n          console.log(`Fetching telemetry data from URL: ${telemetryUrl} (attempt ${2 - retries + 1}/3)`);\n\n          // Make API request with extended timeout for large telemetry files\n          const response = await axios.get(telemetryUrl, {\n            headers,\n            timeout: 60000 // 60 second timeout for telemetry\n          });\n\n          // Cache the telemetry data\n          try {\n            localStorage.setItem(cacheKey, JSON.stringify(response.data));\n            console.log(`Cached telemetry data for match: ${matchId}`);\n          } catch (e) {\n            // Local storage might be full - telemetry can be very large\n            console.warn('Could not cache telemetry data - likely too large for localStorage');\n            // Try to clear some space\n            if (cacheService && cacheService.clearOldCache) {\n              cacheService.clearOldCache();\n            }\n          }\n          return response.data;\n        } catch (error) {\n          lastError = error;\n\n          // If it's a 404, don't retry\n          if (error.response && error.response.status === 404) {\n            throw new Error('Telemetry data not found');\n          }\n\n          // Don't retry if we've exhausted retries\n          if (retries <= 0) {\n            break;\n          }\n\n          // Wait before retry (5s, then 10s) - telemetry is large so we wait longer\n          const delay = (3 - retries) * 5000;\n          console.log(`Telemetry request failed. Retrying after ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n          retries--;\n        }\n      }\n\n      // Handle specific error cases after all retries failed\n      if (lastError.response) {\n        if (lastError.response.status === 404) {\n          throw new Error('Telemetry data not found');\n        } else if (lastError.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          var _lastError$response$d3;\n          throw new Error(`API error: ${((_lastError$response$d3 = lastError.response.data) === null || _lastError$response$d3 === void 0 ? void 0 : _lastError$response$d3.error) || 'Unknown error'}`);\n        }\n      } else if (lastError.code === 'ECONNABORTED') {\n        throw new Error('Request timed out. Telemetry data might be too large.');\n      } else if (lastError.code === 'ECONNRESET') {\n        throw new Error('Connection reset while fetching telemetry. Please try again later.');\n      } else if (lastError.request) {\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        throw lastError;\n      }\n    } catch (error) {\n      console.error('Error in getTelemetry:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Register a match to a tournament with enhanced error handling\n   * @param {Object} matchData - Match registration data\n   * @returns {Promise<Object>} Registration result\n   */\n  async registerMatch(matchData) {\n    try {\n      // Get auth token (required for this operation)\n      const token = authService.getToken();\n      if (!token) {\n        throw new Error('Authentication required');\n      }\n\n      // Request headers\n      const headers = {\n        Authorization: `Bearer ${token}`\n      };\n\n      // Implement retry logic with exponential backoff\n      let retries = 1; // Fewer retries for write operations\n      let lastError = null;\n      while (retries >= 0) {\n        try {\n          console.log(`Registering match (attempt ${1 - retries + 1}/2)`);\n\n          // Make API request\n          const response = await axios.post('/api/matches/register', matchData, {\n            headers,\n            timeout: 30000 // 30 second timeout\n          });\n          return response.data;\n        } catch (error) {\n          lastError = error;\n\n          // If it's a 404, 401, or 409, don't retry\n          if (error.response && [404, 401, 409].includes(error.response.status)) {\n            throw error;\n          }\n\n          // Don't retry if we've exhausted retries\n          if (retries <= 0) {\n            break;\n          }\n\n          // Wait before retry (3s)\n          const delay = 3000;\n          console.log(`Registration failed. Retrying after ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n          retries--;\n        }\n      }\n\n      // Handle specific error cases\n      if (lastError.response) {\n        // Server responded with an error status\n        if (lastError.response.status === 401) {\n          throw new Error('Authentication required');\n        } else if (lastError.response.status === 404) {\n          throw new Error('Match not found');\n        } else if (lastError.response.status === 409) {\n          throw new Error('Match is already registered to a tournament');\n        } else if (lastError.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          var _lastError$response$d4;\n          throw new Error(`API error: ${((_lastError$response$d4 = lastError.response.data) === null || _lastError$response$d4 === void 0 ? void 0 : _lastError$response$d4.error) || 'Unknown error'}`);\n        }\n      } else if (lastError.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw lastError;\n      }\n    } catch (error) {\n      console.error('Error in registerMatch:', error);\n      throw error;\n    }\n  }\n}\nexport default new MatchesServiceEnhanced();","map":{"version":3,"names":["axios","authService","cacheService","require","default","e","getMatch","storeMatch","clearOldCache","console","warn","MatchesServiceEnhanced","searchMatches","criteria","token","getToken","headers","Authorization","retries","lastError","log","response","post","timeout","data","error","status","delay","Promise","resolve","setTimeout","Error","_lastError$response$d","statusText","code","request","getMatchDetails","matchId","platform","bypassCache","cachedMatch","get","_lastError$response$d2","getTelemetry","telemetryUrl","cacheKey","cachedTelemetry","localStorage","getItem","parsed","JSON","parse","removeItem","matchData","included","assets","filter","item","type","length","_assets$","_assets$$attributes","attributes","URL","setItem","stringify","_lastError$response$d3","registerMatch","includes","_lastError$response$d4"],"sources":["C:/Users/emil/OneDrive/Documents/development/apiDevelopment/pubg-tournament-tracker/client/src/services/matchesServiceEnhanced.js"],"sourcesContent":["import axios from 'axios';\nimport authService from './authService';\n\n// Import the cache service if available\nlet cacheService;\ntry {\n  cacheService = require('./cacheService').default;\n} catch (e) {\n  // Create a simple cache if the service doesn't exist\n  cacheService = {\n    getMatch: () => null,\n    storeMatch: () => {},\n    clearOldCache: () => {}\n  };\n  console.warn('CacheService not available, using fallback cache');\n}\n\nclass MatchesServiceEnhanced {\n  /**\n   * Search for matches with enhanced error handling and retry logic\n   * @param {Object} criteria - Search criteria \n   * @returns {Promise<Object>} Search results\n   */\n  async searchMatches(criteria) {\n    try {\n      // Get auth token if available\n      const token = authService.getToken();\n      \n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // Implement retry logic with exponential backoff\n      let retries = 2;\n      let lastError = null;\n      \n      while (retries >= 0) {\n        try {\n          console.log(`Searching for matches (attempt ${2 - retries + 1}/3)`);\n          \n          // Add a timeout to prevent hanging requests\n          const response = await axios.post('/api/matches/search', criteria, { \n            headers,\n            timeout: 30000 // 30 second timeout for search\n          });\n          \n          // Make sure we return the data in the expected format\n          return response.data;\n        } catch (error) {\n          lastError = error;\n          \n          // If it's a 404 or other specific error, don't retry\n          if (error.response && error.response.status === 404) {\n            throw error;\n          }\n          \n          // Don't retry if we've exhausted retries\n          if (retries <= 0) {\n            break;\n          }\n          \n          // Wait before retry (2s, then 4s)\n          const delay = (3 - retries) * 2000;\n          console.log(`Search failed. Retrying after ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n          \n          retries--;\n        }\n      }\n      \n      // If we reach here, all retries failed\n      console.error('All search attempts failed:', lastError);\n      \n      // Handle specific error cases\n      if (lastError.response) {\n        // Server responded with an error status\n        if (lastError.response.status === 401) {\n          throw new Error('Authentication required');\n        } else if (lastError.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          throw new Error(`API error: ${lastError.response.data?.error || lastError.response.statusText || 'Unknown error'}`);\n        }\n      } else if (lastError.code === 'ECONNABORTED') {\n        // Request timed out\n        throw new Error('Request timed out. The server might be overloaded or try a more specific search.');\n      } else if (lastError.code === 'ECONNRESET') {\n        // Connection reset by server\n        throw new Error('Connection reset by server. Please try a more specific search with fewer results.');\n      } else if (lastError.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection and try again.');\n      } else {\n        // Something else went wrong\n        throw lastError;\n      }\n    } catch (error) {\n      console.error('Error in searchMatches:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get match details by ID with enhanced error handling, retry logic and caching\n   * @param {string} matchId - PUBG match ID\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API even if cached\n   * @returns {Promise<Object>} Match data\n   */\n  async getMatchDetails(matchId, platform = 'steam', bypassCache = false) {\n    try {\n      // First, check if we have this match cached (unless bypass requested)\n      if (!bypassCache && cacheService) {\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log(`Using cached data for match: ${matchId}`);\n          return cachedMatch;\n        }\n      }\n      \n      // Get auth token if available\n      const token = authService.getToken();\n      \n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // Implement retry logic with exponential backoff\n      let retries = 2;\n      let lastError = null;\n      \n      while (retries >= 0) {\n        try {\n          console.log(`Fetching match data from API: ${matchId} (attempt ${2 - retries + 1}/3)`);\n          \n          // Make API request with timeout\n          const response = await axios.get(`/api/matches/${matchId}?platform=${platform}`, { \n            headers,\n            timeout: 30000 // 30 second timeout\n          });\n          \n          // If response is empty or missing key attributes, throw an error\n          if (!response.data || !response.data.data) {\n            throw new Error('Invalid response format from API');\n          }\n          \n          // Cache the successful response\n          if (cacheService) {\n            cacheService.storeMatch(matchId, platform, response.data);\n          }\n          \n          return response.data;\n        } catch (error) {\n          lastError = error;\n          \n          // If it's a 404, don't retry\n          if (error.response && error.response.status === 404) {\n            throw new Error('Match not found');\n          }\n          \n          // Don't retry if we've exhausted retries\n          if (retries <= 0) {\n            break;\n          }\n          \n          // For rate limiting, wait longer\n          if (error.response && error.response.status === 429) {\n            // Check cache as fallback for rate limiting\n            if (cacheService) {\n              const cachedMatch = cacheService.getMatch(matchId, platform);\n              if (cachedMatch) {\n                console.log('Using cached data due to rate limiting');\n                return cachedMatch;\n              }\n            }\n            \n            const delay = 5000; // 5 seconds for rate limit\n            console.log(`Rate limit hit. Waiting ${delay}ms before retry...`);\n            await new Promise(resolve => setTimeout(resolve, delay));\n          } else {\n            // Regular exponential backoff for other errors\n            const delay = (3 - retries) * 2000;\n            console.log(`Request failed. Retrying after ${delay}ms...`);\n            await new Promise(resolve => setTimeout(resolve, delay));\n          }\n          \n          retries--;\n        }\n      }\n      \n      // If we reach here, all retries failed\n      console.error('All match detail requests failed:', lastError);\n      \n      // Check if we have any cached data as fallback\n      if (cacheService) {\n        const cachedMatch = cacheService.getMatch(matchId, platform);\n        if (cachedMatch) {\n          console.log('Using cached data after all retries failed');\n          return cachedMatch;\n        }\n      }\n      \n      // Handle specific error cases\n      if (lastError.response) {\n        if (lastError.response.status === 404) {\n          throw new Error('Match not found');\n        } else if (lastError.response.status === 429) {\n          throw new Error('API rate limit exceeded and no cached data available. Please try again later.');\n        } else if (lastError.response.status === 401) {\n          throw new Error('Authentication required');\n        } else {\n          throw new Error(`API error: ${lastError.response.data?.error || 'Unknown error'}`);\n        }\n      } else if (lastError.code === 'ECONNABORTED') {\n        // Request timed out\n        throw new Error('Request timed out. The server might be overloaded.');\n      } else if (lastError.code === 'ECONNRESET') {\n        // Connection reset by server\n        throw new Error('Connection reset by server. Please try again later.');\n      } else if (lastError.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw lastError;\n      }\n    } catch (error) {\n      console.error('Error in getMatchDetails:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get telemetry data for a match with enhanced error handling and caching\n   * @param {string} matchId - PUBG match ID\n   * @param {string} telemetryUrl - URL to telemetry data (if known)\n   * @param {string} platform - Platform (default: steam)\n   * @param {boolean} bypassCache - Force refresh from API\n   * @returns {Promise<Object>} Telemetry data\n   */\n  async getTelemetry(matchId, telemetryUrl = null, platform = 'steam', bypassCache = false) {\n    const cacheKey = `telemetry_${matchId}`;\n    \n    try {\n      // Check cache first\n      if (!bypassCache) {\n        // We use the regular localStorage for telemetry due to its large size\n        const cachedTelemetry = localStorage.getItem(cacheKey);\n        if (cachedTelemetry) {\n          try {\n            const parsed = JSON.parse(cachedTelemetry);\n            console.log(`Using cached telemetry data for match: ${matchId}`);\n            return parsed;\n          } catch (e) {\n            // Invalid cache, remove it\n            localStorage.removeItem(cacheKey);\n          }\n        }\n      }\n      \n      // Get auth token if available\n      const token = authService.getToken();\n      \n      // Request headers\n      const headers = {};\n      if (token) {\n        headers.Authorization = `Bearer ${token}`;\n      }\n\n      // We need to get the telemetry URL first if not provided\n      if (!telemetryUrl) {\n        console.log(`Fetching match data to get telemetry URL: ${matchId}`);\n        // Try to get from cache first\n        let matchData = null;\n        \n        try {\n          matchData = await this.getMatchDetails(matchId, platform, bypassCache);\n          \n          // Extract telemetry URL from match data\n          if (matchData.data && matchData.included) {\n            const assets = matchData.included.filter(item => item.type === 'asset');\n            if (assets.length > 0) {\n              telemetryUrl = assets[0]?.attributes?.URL;\n            }\n          }\n        } catch (error) {\n          console.error('Error getting match data for telemetry:', error);\n        }\n        \n        if (!telemetryUrl) {\n          throw new Error('Could not find telemetry URL for this match');\n        }\n      }\n\n      // Implement retry logic with exponential backoff\n      let retries = 2;\n      let lastError = null;\n      \n      while (retries >= 0) {\n        try {\n          console.log(`Fetching telemetry data from URL: ${telemetryUrl} (attempt ${2 - retries + 1}/3)`);\n          \n          // Make API request with extended timeout for large telemetry files\n          const response = await axios.get(telemetryUrl, { \n            headers,\n            timeout: 60000 // 60 second timeout for telemetry\n          });\n          \n          // Cache the telemetry data\n          try {\n            localStorage.setItem(cacheKey, JSON.stringify(response.data));\n            console.log(`Cached telemetry data for match: ${matchId}`);\n          } catch (e) {\n            // Local storage might be full - telemetry can be very large\n            console.warn('Could not cache telemetry data - likely too large for localStorage');\n            // Try to clear some space\n            if (cacheService && cacheService.clearOldCache) {\n              cacheService.clearOldCache();\n            }\n          }\n          \n          return response.data;\n        } catch (error) {\n          lastError = error;\n          \n          // If it's a 404, don't retry\n          if (error.response && error.response.status === 404) {\n            throw new Error('Telemetry data not found');\n          }\n          \n          // Don't retry if we've exhausted retries\n          if (retries <= 0) {\n            break;\n          }\n          \n          // Wait before retry (5s, then 10s) - telemetry is large so we wait longer\n          const delay = (3 - retries) * 5000;\n          console.log(`Telemetry request failed. Retrying after ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n          \n          retries--;\n        }\n      }\n      \n      // Handle specific error cases after all retries failed\n      if (lastError.response) {\n        if (lastError.response.status === 404) {\n          throw new Error('Telemetry data not found');\n        } else if (lastError.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          throw new Error(`API error: ${lastError.response.data?.error || 'Unknown error'}`);\n        }\n      } else if (lastError.code === 'ECONNABORTED') {\n        throw new Error('Request timed out. Telemetry data might be too large.');\n      } else if (lastError.code === 'ECONNRESET') {\n        throw new Error('Connection reset while fetching telemetry. Please try again later.');\n      } else if (lastError.request) {\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        throw lastError;\n      }\n    } catch (error) {\n      console.error('Error in getTelemetry:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Register a match to a tournament with enhanced error handling\n   * @param {Object} matchData - Match registration data\n   * @returns {Promise<Object>} Registration result\n   */\n  async registerMatch(matchData) {\n    try {\n      // Get auth token (required for this operation)\n      const token = authService.getToken();\n      if (!token) {\n        throw new Error('Authentication required');\n      }\n      \n      // Request headers\n      const headers = {\n        Authorization: `Bearer ${token}`\n      };\n\n      // Implement retry logic with exponential backoff\n      let retries = 1; // Fewer retries for write operations\n      let lastError = null;\n      \n      while (retries >= 0) {\n        try {\n          console.log(`Registering match (attempt ${1 - retries + 1}/2)`);\n          \n          // Make API request\n          const response = await axios.post('/api/matches/register', matchData, { \n            headers,\n            timeout: 30000 // 30 second timeout\n          });\n          \n          return response.data;\n        } catch (error) {\n          lastError = error;\n          \n          // If it's a 404, 401, or 409, don't retry\n          if (error.response && [404, 401, 409].includes(error.response.status)) {\n            throw error;\n          }\n          \n          // Don't retry if we've exhausted retries\n          if (retries <= 0) {\n            break;\n          }\n          \n          // Wait before retry (3s)\n          const delay = 3000;\n          console.log(`Registration failed. Retrying after ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n          \n          retries--;\n        }\n      }\n      \n      // Handle specific error cases\n      if (lastError.response) {\n        // Server responded with an error status\n        if (lastError.response.status === 401) {\n          throw new Error('Authentication required');\n        } else if (lastError.response.status === 404) {\n          throw new Error('Match not found');\n        } else if (lastError.response.status === 409) {\n          throw new Error('Match is already registered to a tournament');\n        } else if (lastError.response.status === 429) {\n          throw new Error('API rate limit exceeded. Please try again later.');\n        } else {\n          throw new Error(`API error: ${lastError.response.data?.error || 'Unknown error'}`);\n        }\n      } else if (lastError.request) {\n        // No response received\n        throw new Error('No response from server. Please check your connection.');\n      } else {\n        // Something else went wrong\n        throw lastError;\n      }\n    } catch (error) {\n      console.error('Error in registerMatch:', error);\n      throw error;\n    }\n  }\n}\n\nexport default new MatchesServiceEnhanced();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}